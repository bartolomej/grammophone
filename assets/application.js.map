{"version":3,"file":"application.js","sources":["../../node_modules/mithril/render/vnode.js","../../node_modules/mithril/render/render.js","../../node_modules/mithril/render.js","../../node_modules/mithril/render/hyperscriptVnode.js","../../node_modules/mithril/render/hyperscript.js","../../node_modules/mithril/render/trust.js","../../node_modules/mithril/render/fragment.js","../../node_modules/mithril/hyperscript.js","../../src/templates/header.js","../../src/views/header_view.js","../../src/templates/blank_slate.js","../../src/views/blank_slate_view.js","../../src/grammar/symbols.js","../../src/helpers.js","../../src/set_operations.js","../../src/templates/sanity.js","../../src/views/sanity_view.js","../../src/templates/sentences.js","../../src/views/sentences_view.js","../../src/views/short_sentences_view.js","../../src/templates/nonterminals.js","../../src/views/nonterminals_view.js","../../src/templates/parsing.js","../../src/views/parsing_view.js","../../src/templates/ll1_table.js","../../src/views/ll1_table_view.js","../../src/templates/lr_automaton_graph.js","../../src/views/lr0_automaton_view.js","../../src/templates/lr0_table.js","../../src/views/lr0_table_view.js","../../src/templates/lr1_table.js","../../src/views/slr1_table_view.js","../../src/views/lr1_automaton_view.js","../../src/views/lr1_table_view.js","../../src/views/lalr1_automaton_view.js","../../src/views/lalr1_table_view.js","../../src/controllers/analysis_controller.js","../../src/templates/edit.js","../../src/controllers/edit_controller.js","../../src/templates/transform.js","../../src/views/transform_view.js","../../src/controllers/transform_controller.js","../../src/templates/mode.js","../../src/controllers/mode_controller.js","../../src/grammar/calculations/grammar/classification.js","../../src/grammar/calculations/grammar/nonterminals.js","../../src/grammar/calculations/grammar/terminals.js","../../src/grammar/calculations/grammar/symbolInfo.js","../../src/grammar/calculations/grammar/start.js","../../src/grammar/calculations/grammar/productions.js","../../src/controllers/error_controller.js","../../src/relation.js","../../src/grammar/calculations/grammar/unreachable.js","../../src/grammar/calculations/grammar/unrealizable.js","../../src/grammar/calculations/grammar/cycle.js","../../src/grammar/calculations/grammar/nullAmbiguity.js","../../src/grammar/calculations/grammar/nullable.js","../../src/grammar/calculations/grammar/first.js","../../src/grammar/calculations/grammar/follow.js","../../src/grammar/calculations/grammar/endable.js","../../src/grammar/calculations/grammar/sentences.js","../../src/grammar/calculations/grammar/ambiguous.js","../../src/grammar/calculations/parsing/ll/ll1_classification.js","../../src/grammar/calculations/parsing/ll/ll1_table.js","../../src/grammar/calculations/parsing/lr/lr0_classification.js","../../src/grammar/calculations/parsing/lr/helpers.js","../../src/grammar/calculations/parsing/lr/lr0_automaton.js","../../src/grammar/calculations/parsing/lr/build/lr0.js","../../src/grammar/calculations/parsing/lr/lr0_table.js","../../src/grammar/calculations/parsing/lr/slr1_classification.js","../../src/grammar/calculations/parsing/lr/slr1_table.js","../../src/grammar/calculations/parsing/lr/build/lr1.js","../../src/grammar/calculations/parsing/lr/lr1_automaton.js","../../src/grammar/calculations/parsing/lr/lr1_classification.js","../../src/grammar/calculations/parsing/lr/lr1_table.js","../../src/grammar/calculations/parsing/lr/lalr1_classification.js","../../src/grammar/calculations/parsing/lr/lalr1_automaton.js","../../src/grammar/calculations/parsing/lr/lalr1_table.js","../../src/grammar/calculations/transformations/expand.js","../../src/grammar/calculations/transformations/removeImmediateLeftRecursion.js","../../src/grammar/calculations/transformations/leftFactor.js","../../src/grammar/calculations/transformations/epsilonSeparate.js","../../src/grammar/calculations/transformations/removeUnreachable.js","../../src/grammar/calculations/transformations/all.js","../../src/grammar/calculations/index.js","../../src/grammar/index.js","../../node_modules/@lezer/common/dist/index.cjs","../../node_modules/@lezer/lr/dist/index.cjs","../../src/parser/tokens.js","../../src/parser/rules.terms.js","../../src/parser/rules.js","../../src/parser/index.js","../../src/controllers/application_controller.js","../../src/application.js"],"sourcesContent":["\"use strict\"\n\nfunction Vnode(tag, key, attrs, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node == null || typeof node === \"boolean\") return null\n\tif (typeof node === \"object\") return node\n\treturn Vnode(\"#\", undefined, undefined, String(node), undefined, undefined)\n}\nVnode.normalizeChildren = function(input) {\n\tvar children = []\n\tif (input.length) {\n\t\tvar isKeyed = input[0] != null && input[0].key != null\n\t\t// Note: this is a *very* perf-sensitive check.\n\t\t// Fun fact: merging the loop like this is somehow faster than splitting\n\t\t// it, noticeably so.\n\t\tfor (var i = 1; i < input.length; i++) {\n\t\t\tif ((input[i] != null && input[i].key != null) !== isKeyed) {\n\t\t\t\tthrow new TypeError(\"Vnodes must either always have keys or never have keys!\")\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tchildren[i] = Vnode.normalize(input[i])\n\t\t}\n\t}\n\treturn children\n}\n\nmodule.exports = Vnode\n","\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\nmodule.exports = function($window) {\n\tvar $doc = $window && $window.document\n\tvar currentRedraw\n\n\tvar nameSpace = {\n\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t}\n\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\n\t//sanity check to discourage people from doing `vnode.state = ...`\n\tfunction checkState(vnode, original) {\n\t\tif (vnode.state !== original) throw new Error(\"`vnode.state` must not be modified\")\n\t}\n\n\t//Note: the hook is passed as the `this` argument to allow proxying the\n\t//arguments without requiring a full array allocation to do so. It also\n\t//takes advantage of the fact the current `vnode` is the first argument in\n\t//all lifecycle methods.\n\tfunction callHook(vnode) {\n\t\tvar original = vnode.state\n\t\ttry {\n\t\t\treturn this.apply(original, arguments)\n\t\t} finally {\n\t\t\tcheckState(vnode, original)\n\t\t}\n\t}\n\n\t// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when\n\t// inside an iframe. Catch and swallow this error, and heavy-handidly return null.\n\tfunction activeElement() {\n\t\ttry {\n\t\t\treturn $doc.activeElement\n\t\t} catch (e) {\n\t\t\treturn null\n\t\t}\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": createText(parent, vnode, nextSibling); break\n\t\t\t\tcase \"<\": createHTML(parent, vnode, ns, nextSibling); break\n\t\t\t\tcase \"[\": createFragment(parent, vnode, hooks, ns, nextSibling); break\n\t\t\t\tdefault: createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t}\n\tvar possibleParents = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}\n\tfunction createHTML(parent, vnode, ns, nextSibling) {\n\t\tvar match = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\t// not using the proper parent makes the child element(s) vanish.\n\t\t//     var div = document.createElement(\"div\")\n\t\t//     div.innerHTML = \"<td>i</td><td>j</td>\"\n\t\t//     console.log(div.innerHTML)\n\t\t// --> \"ij\", no <td> in sight.\n\t\tvar temp = $doc.createElement(possibleParents[match[1]] || \"div\")\n\t\tif (ns === \"http://www.w3.org/2000/svg\") {\n\t\t\ttemp.innerHTML = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\">\" + vnode.children + \"</svg>\"\n\t\t\ttemp = temp.firstChild\n\t\t} else {\n\t\t\ttemp.innerHTML = vnode.children\n\t\t}\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\t// Capture nodes to remove, so we don't confuse them.\n\t\tvnode.instance = []\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tvnode.instance.push(child)\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs = vnode.attrs\n\t\tvar is = attrs && attrs.is\n\n\t\tns = getNameSpace(vnode) || ns\n\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\n\t\tif (attrs != null) {\n\t\t\tsetAttrs(vnode, attrs, ns)\n\t\t}\n\n\t\tinsertNode(parent, element, nextSibling)\n\n\t\tif (!maybeSetContentEditable(vnode)) {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tif (vnode.tag === \"select\" && attrs != null) setLateSelectAttrs(vnode, attrs)\n\t\t\t}\n\t\t}\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tinitLifecycle(vnode.state, vnode, hooks)\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tcreateNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t}\n\t}\n\n\t//update\n\t/**\n\t * @param {Element|Fragment} parent - the parent element\n\t * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for\n\t *                               this part of the tree\n\t * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.\n\t * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)\n\t * @param {Element | null} nextSibling - the next DOM node if we're dealing with a\n\t *                                       fragment that is not the last item in its\n\t *                                       parent\n\t * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any\n\t * @returns void\n\t */\n\t// This function diffs and patches lists of vnodes, both keyed and unkeyed.\n\t//\n\t// We will:\n\t//\n\t// 1. describe its general structure\n\t// 2. focus on the diff algorithm optimizations\n\t// 3. discuss DOM node operations.\n\n\t// ## Overview:\n\t//\n\t// The updateNodes() function:\n\t// - deals with trivial cases\n\t// - determines whether the lists are keyed or unkeyed based on the first non-null node\n\t//   of each list.\n\t// - diffs them and patches the DOM if needed (that's the brunt of the code)\n\t// - manages the leftovers: after diffing, are there:\n\t//   - old nodes left to remove?\n\t// \t - new nodes to insert?\n\t// \t deal with them!\n\t//\n\t// The lists are only iterated over once, with an exception for the nodes in `old` that\n\t// are visited in the fourth part of the diff and in the `removeNodes` loop.\n\n\t// ## Diffing\n\t//\n\t// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837\n\t// may be good for context on longest increasing subsequence-based logic for moving nodes.\n\t//\n\t// In order to diff keyed lists, one has to\n\t//\n\t// 1) match nodes in both lists, per key, and update them accordingly\n\t// 2) create the nodes present in the new list, but absent in the old one\n\t// 3) remove the nodes present in the old list, but absent in the new one\n\t// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.\n\t//\n\t// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate\n\t// over the new list and for each new vnode, find the corresponding vnode in the old list using\n\t// the map.\n\t// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new\n\t// and must be created.\n\t// For the removals, we actually remove the nodes that have been updated from the old list.\n\t// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.\n\t// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)\n\t// algorithm.\n\t//\n\t// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going\n\t// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices\n\t// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would\n\t//  match the above lists, for example).\n\t//\n\t// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We\n\t// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.\n\t//\n\t// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually\n\t// the longest increasing subsequence *of old nodes still present in the new list*).\n\t//\n\t// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation\n\t// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,\n\t// the `LIS` and a temporary one to create the LIS).\n\t//\n\t// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of\n\t// the LIS and can be updated without moving them.\n\t//\n\t// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with\n\t// the exception of the last node if the list is fully reversed).\n\t//\n\t// ## Finding the next sibling.\n\t//\n\t// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.\n\t// When the list is being traversed top-down, at any index, the DOM nodes up to the previous\n\t// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old\n\t// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.\n\t//\n\t// In the other scenarios (swaps, upwards traversal, map-based diff),\n\t// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the\n\t// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node\n\t// as the next sibling (cached in the `nextSibling` variable).\n\n\n\t// ## DOM node moves\n\t//\n\t// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,\n\t// this is not the case if the node moved (second and fourth part of the diff algo). We move\n\t// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`\n\t// variable rather than fetching it using `getNextSibling()`.\n\t//\n\t// The fourth part of the diff currently inserts nodes unconditionally, leading to issues\n\t// like #1791 and #1999. We need to be smarter about those situations where adjascent old\n\t// nodes remain together in the new list in a way that isn't covered by parts one and\n\t// three of the diff algo.\n\n\tfunction updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length)\n\t\telse {\n\t\t\tvar isOldKeyed = old[0] != null && old[0].key != null\n\t\t\tvar isKeyed = vnodes[0] != null && vnodes[0].key != null\n\t\t\tvar start = 0, oldStart = 0\n\t\t\tif (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++\n\t\t\tif (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++\n\t\t\tif (isKeyed === null && isOldKeyed == null) return // both lists are full of nulls\n\t\t\tif (isOldKeyed !== isKeyed) {\n\t\t\t\tremoveNodes(parent, old, oldStart, old.length)\n\t\t\t\tcreateNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else if (!isKeyed) {\n\t\t\t\t// Don't index past the end of either list (causes deopts).\n\t\t\t\tvar commonLength = old.length < vnodes.length ? old.length : vnodes.length\n\t\t\t\t// Rewind if necessary to the first non-null index on either side.\n\t\t\t\t// We could alternatively either explicitly create or remove nodes when `start !== oldStart`\n\t\t\t\t// but that would be optimizing for sparse lists which are more rare than dense ones.\n\t\t\t\tstart = start < oldStart ? start : oldStart\n\t\t\t\tfor (; start < commonLength; start++) {\n\t\t\t\t\to = old[start]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o === v || o == null && v == null) continue\n\t\t\t\t\telse if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))\n\t\t\t\t\telse if (v == null) removeNode(parent, o)\n\t\t\t\t\telse updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\tif (old.length > commonLength) removeNodes(parent, old, start, old.length)\n\t\t\t\tif (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else {\n\t\t\t\t// keyed diff\n\t\t\t\tvar oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling\n\n\t\t\t\t// bottom-up\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\t// top-down\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o.key !== v.key) break\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tif (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\t// swaps and list reversals\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (start === end) break\n\t\t\t\t\tif (o.key !== ve.key || oe.key !== v.key) break\n\t\t\t\t\ttopSibling = getNextSibling(old, oldStart, nextSibling)\n\t\t\t\t\tmoveNodes(parent, oe, topSibling)\n\t\t\t\t\tif (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)\n\t\t\t\t\tif (++start <= --end) moveNodes(parent, o, nextSibling)\n\t\t\t\t\tif (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldStart++; oldEnd--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t}\n\t\t\t\t// bottom up once again\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t}\n\t\t\t\tif (start > end) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\telse if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\telse {\n\t\t\t\t\t// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul\n\t\t\t\t\tvar originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices\n\t\t\t\t\tfor (i = 0; i < vnodesLength; i++) oldIndices[i] = -1\n\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\tif (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)\n\t\t\t\t\t\tve = vnodes[i]\n\t\t\t\t\t\tvar oldIndex = map[ve.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tpos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered\n\t\t\t\t\t\t\toldIndices[i-start] = oldIndex\n\t\t\t\t\t\t\toe = old[oldIndex]\n\t\t\t\t\t\t\told[oldIndex] = null\n\t\t\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\t\t\tmatched++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnextSibling = originalNextSibling\n\t\t\t\t\tif (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\t\tif (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (pos === -1) {\n\t\t\t\t\t\t\t// the indices of the indices of the items that are part of the\n\t\t\t\t\t\t\t// longest increasing subsequence in the oldIndices list\n\t\t\t\t\t\t\tlisIndices = makeLisIndices(oldIndices)\n\t\t\t\t\t\t\tli = lisIndices.length - 1\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (lisIndices[li] === i - start) li--\n\t\t\t\t\t\t\t\t\telse moveNodes(parent, v, nextSibling)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode.events = old.events\n\t\t\tif (shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tupdateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, ns, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(parent, old)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, ns, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\tremoveHTML(parent, old)\n\t\t\tcreateHTML(parent, vnode, ns, nextSibling)\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t}\n\t}\n\tfunction updateFragment(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (!maybeSetContentEditable(vnode)) {\n\t\t\tif (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t\tupdateNodes(element, old.children, vnode.children, hooks, null, ns)\n\t\t\t}\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, ns) {\n\t\tvnode.instance = Vnode.normalize(callHook.call(vnode.state.view, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tupdateLifecycle(vnode.state, vnode, hooks)\n\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(parent, old.instance)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction getKeyMap(vnodes, start, end) {\n\t\tvar map = Object.create(null)\n\t\tfor (; start < end; start++) {\n\t\t\tvar vnode = vnodes[start]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key = vnode.key\n\t\t\t\tif (key != null) map[key] = start\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\t// Lifted from ivi https://github.com/ivijs/ivi/\n\t// takes a list of unique numbers (-1 is special and can\n\t// occur multiple times) and returns an array with the indices\n\t// of the items that are part of the longest increasing\n\t// subsequece\n\tvar lisTemp = []\n\tfunction makeLisIndices(a) {\n\t\tvar result = [0]\n\t\tvar u = 0, v = 0, i = 0\n\t\tvar il = lisTemp.length = a.length\n\t\tfor (var i = 0; i < il; i++) lisTemp[i] = a[i]\n\t\tfor (var i = 0; i < il; ++i) {\n\t\t\tif (a[i] === -1) continue\n\t\t\tvar j = result[result.length - 1]\n\t\t\tif (a[j] < a[i]) {\n\t\t\t\tlisTemp[i] = j\n\t\t\t\tresult.push(i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tu = 0\n\t\t\tv = result.length - 1\n\t\t\twhile (u < v) {\n\t\t\t\t// Fast integer average without overflow.\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tvar c = (u >>> 1) + (v >>> 1) + (u & v & 1)\n\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\tu = c + 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = c\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\tif (u > 0) lisTemp[i] = result[u - 1]\n\t\t\t\tresult[u] = i\n\t\t\t}\n\t\t}\n\t\tu = result.length\n\t\tv = result[u - 1]\n\t\twhile (u-- > 0) {\n\t\t\tresult[u] = v\n\t\t\tv = lisTemp[v]\n\t\t}\n\t\tlisTemp.length = 0\n\t\treturn result\n\t}\n\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\n\t// This covers a really specific edge case:\n\t// - Parent node is keyed and contains child\n\t// - Child is removed, returns unresolved promise in `onbeforeremove`\n\t// - Parent node is moved in keyed diff\n\t// - Remaining children still need moved appropriately\n\t//\n\t// Ideally, I'd track removed nodes as well, but that introduces a lot more\n\t// complexity and I'm not exactly interested in doing that.\n\tfunction moveNodes(parent, vnode, nextSibling) {\n\t\tvar frag = $doc.createDocumentFragment()\n\t\tmoveChildToFrag(parent, frag, vnode)\n\t\tinsertNode(parent, frag, nextSibling)\n\t}\n\tfunction moveChildToFrag(parent, frag, vnode) {\n\t\t// Dodge the recursion overhead in a few of the most common cases.\n\t\twhile (vnode.dom != null && vnode.dom.parentNode === parent) {\n\t\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\t\tvnode = vnode.instance\n\t\t\t\tif (vnode != null) continue\n\t\t\t} else if (vnode.tag === \"<\") {\n\t\t\t\tfor (var i = 0; i < vnode.instance.length; i++) {\n\t\t\t\t\tfrag.appendChild(vnode.instance[i])\n\t\t\t\t}\n\t\t\t} else if (vnode.tag !== \"[\") {\n\t\t\t\t// Don't recurse for text nodes *or* elements, just fragments\n\t\t\t\tfrag.appendChild(vnode.dom)\n\t\t\t} else if (vnode.children.length === 1) {\n\t\t\t\tvnode = vnode.children[0]\n\t\t\t\tif (vnode != null) continue\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < vnode.children.length; i++) {\n\t\t\t\t\tvar child = vnode.children[i]\n\t\t\t\t\tif (child != null) moveChildToFrag(parent, frag, child)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling != null) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\n\tfunction maybeSetContentEditable(vnode) {\n\t\tif (vnode.attrs == null || (\n\t\t\tvnode.attrs.contenteditable == null && // attribute\n\t\t\tvnode.attrs.contentEditable == null // property\n\t\t)) return false\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t\treturn true\n\t}\n\n\t//remove\n\tfunction removeNodes(parent, vnodes, start, end) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) removeNode(parent, vnode)\n\t\t}\n\t}\n\tfunction removeNode(parent, vnode) {\n\t\tvar mask = 0\n\t\tvar original = vnode.state\n\t\tvar stateResult, attrsResult\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onbeforeremove === \"function\") {\n\t\t\tvar result = callHook.call(vnode.state.onbeforeremove, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\tmask = 1\n\t\t\t\tstateResult = result\n\t\t\t}\n\t\t}\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = callHook.call(vnode.attrs.onbeforeremove, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tmask |= 2\n\t\t\t\tattrsResult = result\n\t\t\t}\n\t\t}\n\t\tcheckState(vnode, original)\n\n\t\t// If we can, try to fast-path it and avoid all the overhead of awaiting\n\t\tif (!mask) {\n\t\t\tonremove(vnode)\n\t\t\tremoveChild(parent, vnode)\n\t\t} else {\n\t\t\tif (stateResult != null) {\n\t\t\t\tvar next = function () {\n\t\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\t\tif (mask & 1) { mask &= 2; if (!mask) reallyRemove() }\n\t\t\t\t}\n\t\t\t\tstateResult.then(next, next)\n\t\t\t}\n\t\t\tif (attrsResult != null) {\n\t\t\t\tvar next = function () {\n\t\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\t\tif (mask & 2) { mask &= 1; if (!mask) reallyRemove() }\n\t\t\t\t}\n\t\t\t\tattrsResult.then(next, next)\n\t\t\t}\n\t\t}\n\n\t\tfunction reallyRemove() {\n\t\t\tcheckState(vnode, original)\n\t\t\tonremove(vnode)\n\t\t\tremoveChild(parent, vnode)\n\t\t}\n\t}\n\tfunction removeHTML(parent, vnode) {\n\t\tfor (var i = 0; i < vnode.instance.length; i++) {\n\t\t\tparent.removeChild(vnode.instance[i])\n\t\t}\n\t}\n\tfunction removeChild(parent, vnode) {\n\t\t// Dodge the recursion overhead in a few of the most common cases.\n\t\twhile (vnode.dom != null && vnode.dom.parentNode === parent) {\n\t\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\t\tvnode = vnode.instance\n\t\t\t\tif (vnode != null) continue\n\t\t\t} else if (vnode.tag === \"<\") {\n\t\t\t\tremoveHTML(parent, vnode)\n\t\t\t} else {\n\t\t\t\tif (vnode.tag !== \"[\") {\n\t\t\t\t\tparent.removeChild(vnode.dom)\n\t\t\t\t\tif (!Array.isArray(vnode.children)) break\n\t\t\t\t}\n\t\t\t\tif (vnode.children.length === 1) {\n\t\t\t\t\tvnode = vnode.children[0]\n\t\t\t\t\tif (vnode != null) continue\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = 0; i < vnode.children.length; i++) {\n\t\t\t\t\t\tvar child = vnode.children[i]\n\t\t\t\t\t\tif (child != null) removeChild(parent, child)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tfunction onremove(vnode) {\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onremove === \"function\") callHook.call(vnode.state.onremove, vnode)\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") callHook.call(vnode.attrs.onremove, vnode)\n\t\tif (typeof vnode.tag !== \"string\") {\n\t\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\t} else {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//attrs\n\tfunction setAttrs(vnode, attrs, ns) {\n\t\tfor (var key in attrs) {\n\t\t\tsetAttr(vnode, key, null, attrs[key], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key, old, value, ns) {\n\t\tif (key === \"key\" || key === \"is\" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== \"object\") return\n\t\tif (key[0] === \"o\" && key[1] === \"n\") return updateEvent(vnode, key, value)\n\t\tif (key.slice(0, 6) === \"xlink:\") vnode.dom.setAttributeNS(\"http://www.w3.org/1999/xlink\", key.slice(6), value)\n\t\telse if (key === \"style\") updateStyle(vnode.dom, old, value)\n\t\telse if (hasPropertyKey(vnode, key, ns)) {\n\t\t\tif (key === \"value\") {\n\t\t\t\t// Only do the coercion if we're actually going to check the value.\n\t\t\t\t/* eslint-disable no-implicit-coercion */\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === \"input\" || vnode.tag === \"textarea\") && vnode.dom.value === \"\" + value && vnode.dom === activeElement()) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"select\" && old !== null && vnode.dom.value === \"\" + value) return\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === \"option\" && old !== null && vnode.dom.value === \"\" + value) return\n\t\t\t\t/* eslint-enable no-implicit-coercion */\n\t\t\t}\n\t\t\t// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.\n\t\t\tif (vnode.tag === \"input\" && key === \"type\") vnode.dom.setAttribute(key, value)\n\t\t\telse vnode.dom[key] = value\n\t\t} else {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) vnode.dom.setAttribute(key, \"\")\n\t\t\t\telse vnode.dom.removeAttribute(key)\n\t\t\t}\n\t\t\telse vnode.dom.setAttribute(key === \"className\" ? \"class\" : key, value)\n\t\t}\n\t}\n\tfunction removeAttr(vnode, key, old, ns) {\n\t\tif (key === \"key\" || key === \"is\" || old == null || isLifecycleMethod(key)) return\n\t\tif (key[0] === \"o\" && key[1] === \"n\" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)\n\t\telse if (key === \"style\") updateStyle(vnode.dom, old, null)\n\t\telse if (\n\t\t\thasPropertyKey(vnode, key, ns)\n\t\t\t&& key !== \"className\"\n\t\t\t&& !(key === \"value\" && (\n\t\t\t\tvnode.tag === \"option\"\n\t\t\t\t|| vnode.tag === \"select\" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement()\n\t\t\t))\n\t\t\t&& !(vnode.tag === \"input\" && key === \"type\")\n\t\t) {\n\t\t\tvnode.dom[key] = null\n\t\t} else {\n\t\t\tvar nsLastIndex = key.indexOf(\":\")\n\t\t\tif (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)\n\t\t\tif (old !== false) vnode.dom.removeAttribute(key === \"className\" ? \"class\" : key)\n\t\t}\n\t}\n\tfunction setLateSelectAttrs(vnode, attrs) {\n\t\tif (\"value\" in attrs) {\n\t\t\tif(attrs.value === null) {\n\t\t\t\tif (vnode.dom.selectedIndex !== -1) vnode.dom.value = null\n\t\t\t} else {\n\t\t\t\tvar normalized = \"\" + attrs.value // eslint-disable-line no-implicit-coercion\n\t\t\t\tif (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {\n\t\t\t\t\tvnode.dom.value = normalized\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"selectedIndex\" in attrs) setAttr(vnode, \"selectedIndex\", null, attrs.selectedIndex, undefined)\n\t}\n\tfunction updateAttrs(vnode, old, attrs, ns) {\n\t\tif (attrs != null) {\n\t\t\tfor (var key in attrs) {\n\t\t\t\tsetAttr(vnode, key, old && old[key], attrs[key], ns)\n\t\t\t}\n\t\t}\n\t\tvar val\n\t\tif (old != null) {\n\t\t\tfor (var key in old) {\n\t\t\t\tif (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {\n\t\t\t\t\tremoveAttr(vnode, key, val, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === activeElement() || vnode.tag === \"option\" && vnode.dom.parentNode === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction hasPropertyKey(vnode, key, ns) {\n\t\t// Filter out namespaced keys\n\t\treturn ns === undefined && (\n\t\t\t// If it's a custom element, just keep it.\n\t\t\tvnode.tag.indexOf(\"-\") > -1 || vnode.attrs != null && vnode.attrs.is ||\n\t\t\t// If it's a normal element, let's try to avoid a few browser bugs.\n\t\t\tkey !== \"href\" && key !== \"list\" && key !== \"form\" && key !== \"width\" && key !== \"height\"// && key !== \"type\"\n\t\t\t// Defer the property check until *after* we check everything.\n\t\t) && key in vnode.dom\n\t}\n\n\t//style\n\tvar uppercaseRegex = /[A-Z]/g\n\tfunction toLowerCase(capital) { return \"-\" + capital.toLowerCase() }\n\tfunction normalizeKey(key) {\n\t\treturn key[0] === \"-\" && key[1] === \"-\" ? key :\n\t\t\tkey === \"cssFloat\" ? \"float\" :\n\t\t\t\tkey.replace(uppercaseRegex, toLowerCase)\n\t}\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) {\n\t\t\t// Styles are equivalent, do nothing.\n\t\t} else if (style == null) {\n\t\t\t// New style is missing, just clear it.\n\t\t\telement.style.cssText = \"\"\n\t\t} else if (typeof style !== \"object\") {\n\t\t\t// New style is a string, let engine deal with patching.\n\t\t\telement.style.cssText = style\n\t\t} else if (old == null || typeof old !== \"object\") {\n\t\t\t// `old` is missing or a string, `style` is an object.\n\t\t\telement.style.cssText = \"\"\n\t\t\t// Add new style properties\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null) element.style.setProperty(normalizeKey(key), String(value))\n\t\t\t}\n\t\t} else {\n\t\t\t// Both old & new are (different) objects.\n\t\t\t// Update style properties that have changed\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null && (value = String(value)) !== String(old[key])) {\n\t\t\t\t\telement.style.setProperty(normalizeKey(key), value)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Remove style properties that no longer exist\n\t\t\tfor (var key in old) {\n\t\t\t\tif (old[key] != null && style[key] == null) {\n\t\t\t\t\telement.style.removeProperty(normalizeKey(key))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Here's an explanation of how this works:\n\t// 1. The event names are always (by design) prefixed by `on`.\n\t// 2. The EventListener interface accepts either a function or an object\n\t//    with a `handleEvent` method.\n\t// 3. The object does not inherit from `Object.prototype`, to avoid\n\t//    any potential interference with that (e.g. setters).\n\t// 4. The event name is remapped to the handler before calling it.\n\t// 5. In function-based event handlers, `ev.target === this`. We replicate\n\t//    that below.\n\t// 6. In function-based event handlers, `return false` prevents the default\n\t//    action and stops event propagation. We replicate that below.\n\tfunction EventDict() {\n\t\t// Save this, so the current redraw is correctly tracked.\n\t\tthis._ = currentRedraw\n\t}\n\tEventDict.prototype = Object.create(null)\n\tEventDict.prototype.handleEvent = function (ev) {\n\t\tvar handler = this[\"on\" + ev.type]\n\t\tvar result\n\t\tif (typeof handler === \"function\") result = handler.call(ev.currentTarget, ev)\n\t\telse if (typeof handler.handleEvent === \"function\") handler.handleEvent(ev)\n\t\tif (this._ && ev.redraw !== false) (0, this._)()\n\t\tif (result === false) {\n\t\t\tev.preventDefault()\n\t\t\tev.stopPropagation()\n\t\t}\n\t}\n\n\t//event\n\tfunction updateEvent(vnode, key, value) {\n\t\tif (vnode.events != null) {\n\t\t\tif (vnode.events[key] === value) return\n\t\t\tif (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\t\tif (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false)\n\t\t\t\tvnode.events[key] = value\n\t\t\t} else {\n\t\t\t\tif (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false)\n\t\t\t\tvnode.events[key] = undefined\n\t\t\t}\n\t\t} else if (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\tvnode.events = new EventDict()\n\t\t\tvnode.dom.addEventListener(key.slice(2), vnode.events, false)\n\t\t\tvnode.events[key] = value\n\t\t}\n\t}\n\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") callHook.call(source.oninit, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(callHook.bind(source.oncreate, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(callHook.bind(source.onupdate, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tdo {\n\t\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\tif (typeof vnode.tag !== \"string\" && typeof vnode.state.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode.state.onbeforeupdate, vnode, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\treturn false\n\t\t} while (false); // eslint-disable-line no-constant-condition\n\t\tvnode.dom = old.dom\n\t\tvnode.domSize = old.domSize\n\t\tvnode.instance = old.instance\n\t\t// One would think having the actual latest attributes would be ideal,\n\t\t// but it doesn't let us properly diff based on our current internal\n\t\t// representation. We have to save not only the old DOM info, but also\n\t\t// the attributes used to create it, as we diff *that*, not against the\n\t\t// DOM directly (with a few exceptions in `setAttr`). And, of course, we\n\t\t// need to save the children and text as they are conceptually not\n\t\t// unlike special \"attributes\" internally.\n\t\tvnode.attrs = old.attrs\n\t\tvnode.children = old.children\n\t\tvnode.text = old.text\n\t\treturn true\n\t}\n\n\treturn function(dom, vnodes, redraw) {\n\t\tif (!dom) throw new TypeError(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = activeElement()\n\t\tvar namespace = dom.namespaceURI\n\n\t\t// First time rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\n\t\tvnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])\n\t\tvar prevRedraw = currentRedraw\n\t\ttry {\n\t\t\tcurrentRedraw = typeof redraw === \"function\" ? redraw : undefined\n\t\t\tupdateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace)\n\t\t} finally {\n\t\t\tcurrentRedraw = prevRedraw\n\t\t}\n\t\tdom.vnodes = vnodes\n\t\t// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement\n\t\tif (active != null && activeElement() !== active && typeof active.focus === \"function\") active.focus()\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t}\n}\n","\"use strict\"\n\nmodule.exports = require(\"./render/render\")(window)\n","\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\n// Call via `hyperscriptVnode.apply(startOffset, arguments)`\n//\n// The reason I do it this way, forwarding the arguments and passing the start\n// offset in `this`, is so I don't have to create a temporary array in a\n// performance-critical path.\n//\n// In native ES6, I'd instead add a final `...args` parameter to the\n// `hyperscript` and `fragment` factories and define this as\n// `hyperscriptVnode(...args)`, since modern engines do optimize that away. But\n// ES5 (what Mithril requires thanks to IE support) doesn't give me that luxury,\n// and engines aren't nearly intelligent enough to do either of these:\n//\n// 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to\n//    another function only to be indexed.\n// 2. Elide an `arguments` allocation when it's passed to any function other\n//    than `Function.prototype.apply` or `Reflect.apply`.\n//\n// In ES6, it'd probably look closer to this (I'd need to profile it, though):\n// module.exports = function(attrs, ...children) {\n//     if (attrs == null || typeof attrs === \"object\" && attrs.tag == null && !Array.isArray(attrs)) {\n//         if (children.length === 1 && Array.isArray(children[0])) children = children[0]\n//     } else {\n//         children = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]\n//         attrs = undefined\n//     }\n//\n//     if (attrs == null) attrs = {}\n//     return Vnode(\"\", attrs.key, attrs, children)\n// }\nmodule.exports = function() {\n\tvar attrs = arguments[this], start = this + 1, children\n\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = this\n\t}\n\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\n\treturn Vnode(\"\", attrs.key, attrs, children)\n}\n","\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscriptVnode = require(\"./hyperscriptVnode\")\n\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\n\nfunction isEmpty(object) {\n\tfor (var key in object) if (hasOwn.call(object, key)) return false\n\treturn true\n}\n\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\n\nfunction execSelector(state, vnode) {\n\tvar attrs = vnode.attrs\n\tvar children = Vnode.normalizeChildren(vnode.children)\n\tvar hasClass = hasOwn.call(attrs, \"class\")\n\tvar className = hasClass ? attrs.class : attrs.className\n\n\tvnode.tag = state.tag\n\tvnode.attrs = null\n\tvnode.children = undefined\n\n\tif (!isEmpty(state.attrs) && !isEmpty(attrs)) {\n\t\tvar newAttrs = {}\n\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key)) newAttrs[key] = attrs[key]\n\t\t}\n\n\t\tattrs = newAttrs\n\t}\n\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key) && key !== \"className\" && !hasOwn.call(attrs, key)){\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className != null || state.attrs.className != null) attrs.className =\n\t\tclassName != null\n\t\t\t? state.attrs.className != null\n\t\t\t\t? String(state.attrs.className) + \" \" + String(className)\n\t\t\t\t: className\n\t\t\t: state.attrs.className != null\n\t\t\t\t? state.attrs.className\n\t\t\t\t: null\n\n\tif (hasClass) attrs.class = null\n\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\tvnode.attrs = attrs\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\tvnode.text = children[0].children\n\t} else {\n\t\tvnode.children = children\n\t}\n\n\treturn vnode\n}\n\nfunction hyperscript(selector) {\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\n\tvar vnode = hyperscriptVnode.apply(1, arguments)\n\n\tif (typeof selector === \"string\") {\n\t\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\t\tif (selector !== \"[\") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)\n\t}\n\n\tvnode.tag = selector\n\treturn vnode\n}\n\nmodule.exports = hyperscript\n","\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\n\nmodule.exports = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\n","\"use strict\"\n\nvar Vnode = require(\"../render/vnode\")\nvar hyperscriptVnode = require(\"./hyperscriptVnode\")\n\nmodule.exports = function() {\n\tvar vnode = hyperscriptVnode.apply(0, arguments)\n\n\tvnode.tag = \"[\"\n\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\treturn vnode\n}\n","\"use strict\"\n\nvar hyperscript = require(\"./render/hyperscript\")\n\nhyperscript.trust = require(\"./render/trust\")\nhyperscript.fragment = require(\"./render/fragment\")\n\nmodule.exports = hyperscript\n","const m = require(\"mithril/hyperscript\");\n\nmodule.exports = function(input) {\n  let path = input.path;\n  let segments = [];\n\n  path.forEach(function(segment) {\n    if (segment.path) {\n      segments.push(m(\"a\", { href: \"#\" + segment.path }, segment.title));\n      segments.push(\" / \");\n    } else {\n      segments.push(m(\"b\", segment.title));\n    }\n  });\n\n  return segments.length > 0 ? m(\"nav\", segments) : [];\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/header\");\n\nmodule.exports = class HeaderView {\n  constructor(element) {\n    this._element = element;\n    this._element.className = \"header\";\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      path: this._delegate.getPathComponents()\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const trust = require(\"mithril/render/trust\");\n\nmodule.exports = function() {\n  let result = [];\n\n  result.push(\n    \"<section>\",\n    \"<p><b>Grammophone</b> is a tool for analyzing and transforming context-free grammars. To start, type a grammar in the box to the left and click Analyze or Transform.</p>\",\n    \"<p>Grammars are written like this:</p>\",\n    \"<pre>S -> a S b .\\nS -> .</pre>\",\n    \"<p>This grammar generates the language a<sup>n</sup>&nbsp;b<sup>n</sup>, where n&nbsp;≥&nbsp;0.</p>\",\n    \"</section>\"\n  );\n\n  return trust(result.join(\"\"));\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/blank_slate\");\n\nmodule.exports = class BlankSlateView {\n  constructor(element) {\n    this._element = element;\n    this._element.className = \"blank-slate\";\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({});\n\n    render(this._element, vnode);\n  }\n}\n","module.exports = {\n  END: \"Grammar.END\"\n};\n","const m = require(\"mithril/hyperscript\");\nconst END = require(\"./grammar/symbols\").END;\n\nconst ARROW = \"\\u2192\";\nconst EPSILON = \"\\u03B5\";\nconst PRIME = \"\\u2032\";\n\nfunction fillArray(count, value) {\n  let array = [];\n  for (let i = 0; i < count; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction listSymbols(set, order) {\n  let result = [];\n\n  for (let i = 0; i < order.length; i++) {\n    if (set.has(order[i])) {\n      result.push(order[i]);\n    }\n  }\n\n  if (set.has(END)) {\n    result.push(END);\n  }\n\n  return result;\n}\n\nfunction formatSymbolList(symbols, info, separator) {\n  if (typeof separator === \"undefined\") {\n    separator = \", \";\n  }\n\n  let result = [];\n\n  for (let i = 0; i < symbols.length; i++) {\n    if (i > 0) {\n      result.push(separator);\n    }\n    result.push(formatSymbol(symbols[i], info));\n  }\n\n  return result;\n}\n\nfunction prettifySymbol(symbol) {\n  return symbol.replace(/'/g, PRIME);\n}\n\nfunction formatSymbol(symbol, info) {\n  if (symbol == END) {\n    return m(\"u\", \"$\");\n  } else if (info.nonterminals.has(symbol)) {\n    return m(\"i\", prettifySymbol(symbol));\n  } else if (info.terminals.has(symbol)) {\n    return m(\"b\", prettifySymbol(symbol));\n  } else {\n    throw new Error(\"Unknown symbol: \" + symbol);\n  }\n}\n\nfunction formatProduction(production, info) {\n  let result = [];\n\n  result.push(formatSymbol(production[0], info));\n  result.push(\" \");\n  result.push(ARROW);\n  result.push(\" \");\n\n  if (production.length > 1) {\n    production.slice(1).forEach(function(symbol, index) {\n      if (index > 0) {\n        result.push(\" \");\n      }\n      result.push(formatSymbol(symbol, info));\n    });\n  } else {\n    result.push(m(\"u\", EPSILON));\n  }\n\n  return result;\n}\n\nfunction formatSentence(sentence, info) {\n  let result = [];\n\n  if (sentence.length === 0) {\n    result.push(m(\"u\", EPSILON));\n  } else {\n    sentence.forEach(function(symbol, index) {\n      if (index > 0) {\n        result.push(\" \");\n      }\n      result.push(formatSymbol(symbol, info));\n    });\n  }\n\n  return result;\n}\n\nconst ESCAPE = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"\\\"\": \"&quot;\"\n};\n\nfunction escapeChar(char) {\n  return ESCAPE[char];\n}\n\nfunction escapeString(string) {\n  return string.replace(/[&<>\"]/g, escapeChar);\n}\n\nfunction barePrettifySymbol(symbol) {\n  return symbol.replace(/'/g, \"&prime;\");\n}\n\nfunction bareFormatSymbol(symbol, info) {\n  if (symbol == END) {\n    return \"$\";\n  } else if (info.nonterminals.has(symbol) || info.terminals.has(symbol)) {\n    return barePrettifySymbol(escapeString(symbol));\n  } else {\n    throw new Error(\"Unknown symbol: \" + symbol);\n  }\n}\n\nfunction bareFormatSymbols(symbols, info) {\n  let result = [];\n\n  for (let i = 0; i < symbols.length; i++) {\n    result.push(bareFormatSymbol(symbols[i], info));\n  }\n\n  return result;\n}\n\nfunction bareFormatItem(item, start, productions, info) {\n  let production;\n\n  if (item.production === -1) {\n    if (item.index === 0) {\n      production = \"&bull; \" + bareFormatSymbol(start, info);\n    } else {\n      production = bareFormatSymbol(start, info) + \" &bull;\";\n    }\n  } else {\n    let symbols = bareFormatSymbols(productions[item.production].slice(1), info);\n    symbols.splice(item.index, 0, \"&bull;\");\n\n    production = bareFormatSymbol(productions[item.production][0], info) + \" &rarr; \" + symbols.join(\" \");\n  }\n\n  if (item.lookaheads) {\n    return \"[\" + production + \", \" + bareFormatSymbols(item.lookaheads, info).join(\" / \") + \"]\";\n  } else if (item.lookahead) {\n    return \"[\" + production + \", \" + bareFormatSymbol(item.lookahead, info) + \"]\";\n  } else {\n    return production;\n  }\n}\n\nconst TRANSFORMATION_FORMATTERS = {\n  expand: function(transformation, productions, info) {\n    return \"Expand Nonterminal\";\n  },\n\n  removeImmediateLeftRecursion: function(transformation, productions, info) {\n    return \"Remove Immediate Left Recursion\";\n  },\n\n  leftFactor: function(transformation, productions, info) {\n    return \"Left Factor \" +\n      bareFormatSymbols(productions[transformation.production].slice(1, transformation.length + 1), info).join(\" \");\n  },\n\n  epsilonSeparate: function(transformation, productions, info) {\n    return \"Epsilon-Separate\";\n  },\n\n  removeUnreachable: function(transformation, productions, info) {\n    return \"Remove Unreachable Nonterminal\"\n  }\n}\n\nfunction formatTransformation(transformation, productions, info) {\n  return TRANSFORMATION_FORMATTERS[transformation.name](transformation, productions, info) || transformation.name;\n}\n\nmodule.exports.fillArray = fillArray;\nmodule.exports.listSymbols = listSymbols;\nmodule.exports.formatSymbolList = formatSymbolList;\nmodule.exports.formatSymbol = formatSymbol;\nmodule.exports.formatProduction = formatProduction;\nmodule.exports.formatSentence = formatSentence;\nmodule.exports.escapeString = escapeString;\nmodule.exports.bareFormatSymbol = bareFormatSymbol;\nmodule.exports.bareFormatSymbols = bareFormatSymbols;\nmodule.exports.bareFormatItem = bareFormatItem;\nmodule.exports.formatTransformation = formatTransformation;\n","function any(set) {\n  return set.size > 0;\n}\n\nfunction intersection(a, b) {\n  let result = new Set();\n\n  for (let k of a.values()) {\n    if (b.has(k)) {\n      result.add(k);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports.any = any;\nmodule.exports.intersection = intersection;\n","const m = require(\"mithril/hyperscript\");\nconst Helpers = require(\"../helpers\");\nconst SetOperations = require(\"../set_operations\");\n\nfunction formatUnreachable(unreachable, info) {\n  if (SetOperations.any(unreachable)) {\n    return m(\"li\",\n      \"The grammar has unreachable nonterminals: \",\n      Helpers.formatSymbolList(Helpers.listSymbols(unreachable, info.productionOrder), info)\n    );\n  } else {\n    return m(\"li\", \"All nonterminals are reachable.\");\n  }\n}\n\nfunction formatUnrealizable(unrealizable, info) {\n  if (SetOperations.any(unrealizable)) {\n    return m(\"li\",\n      \"The grammar has unrealizable nonterminals: \",\n      Helpers.formatSymbolList(Helpers.listSymbols(unrealizable, info.productionOrder), info)\n    );\n  } else {\n    return m(\"li\", \"All nonterminals are realizable.\");\n  }\n}\n\nfunction formatCycle(cycle, info) {\n  if (typeof cycle !== \"undefined\") {\n    return m(\"li\",\n      \"The grammar is cyclic: \",\n      Helpers.formatSymbolList(cycle, info, \" \\u21D2 \"),\n      \" is a cycle.\"\n    );\n  } else {\n    return m(\"li\", \"The grammar contains no cycles.\");\n  }\n}\n\nfunction formatNullAmbiguity(nullAmbiguity, productions, info) {\n  if (nullAmbiguity.length > 0) {\n    return m(\"li\",\n      \"The grammar contains a null ambiguity: \",\n      Helpers.formatProduction(productions[nullAmbiguity[0]], info),\n      \" and \",\n      Helpers.formatProduction(productions[nullAmbiguity[1]], info),\n      \" are ambiguously nullable.\"\n    );\n  } else {\n    return m(\"li\", \"The grammar is null unambiguous.\");\n  }\n}\n\nfunction formatAmbiguous(ambiguous, info) {\n  if (typeof ambiguous !== \"undefined\") {\n    return m(\"li\",\n      \"The grammar is ambiguous: the sentence \",\n      Helpers.formatSentence(ambiguous, info),\n      \" has an ambiguous derivation.\"\n    );\n  }\n}\n\nmodule.exports = function(input) {\n  let unreachable = input.unreachable;\n  let unrealizable = input.unrealizable;\n  let cycle = input.cycle;\n  let nullAmbiguity = input.nullAmbiguity;\n  let ambiguous = input.ambiguous;\n  let productions = input.productions;\n  let info = input.info;\n\n  return [\n    m(\"h1\", \"Sanity Checks\"),\n    m(\"ul.symbols\",\n      formatUnreachable(unreachable, info),\n      formatUnrealizable(unrealizable, info),\n      formatCycle(cycle, info),\n      formatNullAmbiguity(nullAmbiguity, productions, info),\n      formatAmbiguous(ambiguous, info)\n    )\n  ];\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/sanity\");\n\nmodule.exports = class SanityView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      unreachable: this._delegate.getCalculation(\"grammar.unreachable\"),\n      unrealizable: this._delegate.getCalculation(\"grammar.unrealizable\"),\n      cycle: this._delegate.getCalculation(\"grammar.cycle\"),\n      nullAmbiguity: this._delegate.getCalculation(\"grammar.nullAmbiguity\"),\n      ambiguous: this._delegate.getCalculation(\"grammar.ambiguous\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\"),\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\nconst Helpers = require(\"../helpers\");\n\nlet maxSentences;\nlet maxDepth;\n\nmodule.exports = function(input) {\n  let sentences = input.sentences;\n  let info = input.info;\n  let limit = input.limit;\n\n  let result = [];\n\n  result.push(m(\"h1\", \"Example Sentences\"));\n\n  function onCalculate() {\n    input.onCalculate({ maxSentences, maxDepth })\n  }\n\n  function onMaxDepthChange(e) {\n    maxDepth = e.target.valueAsNumber;\n  }\n\n  function onMaxSentencesChange(e) {\n    maxSentences = e.target.valueAsNumber;\n  }\n\n  let labelStyle = { marginRight: '10px' }\n\n  let labelTextStyle = { marginRight: '5px' }\n\n  result.push(m('label', {style: labelStyle}, [\n    m(\"span\", {style: labelTextStyle, value: maxDepth}, \"Max depth\"),\n    m(\"input\", {type: 'number', placeholder: 'Max depth', onchange: onMaxDepthChange})\n  ]));\n  result.push(m('label', {style: labelStyle}, [\n    m(\"span\", {style: labelTextStyle, value: maxSentences}, \"Max sentences\"),\n    m(\"input\", {type: 'number', placeholder: 'Max sentences', onchange: onMaxSentencesChange})\n  ]));\n  result.push(m(\"button\", {onclick: onCalculate}, 'Calculate'));\n\n  if (sentences.length > 0) {\n    result.push(\n      m(\"ul.symbols\",\n        sentences.slice(0, limit).map(function(sentence) {\n          return m(\"li\", {style: {whiteSpace: 'nowrap'}}, Helpers.formatSentence(sentence, info));\n        })\n      )\n    );\n\n    if (sentences.length > limit) {\n      result.push(m(\"p\", m(\"a\", { href: \"#/sentences\" }, \"More example sentences\")));\n    }\n  } else {\n    result.push(m(\"p\", \"No example sentences could be generated.\"));\n  }\n\n  return result;\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/sentences\");\n\nmodule.exports = class SentencesView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload(params = {}) {\n    window.console.log(\"reloading with params: \", params)\n    let vnode = template({\n      sentences: this._delegate.getCalculation(\"grammar.sentences\", params),\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      onCalculate: (params) => this.reload(params)\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/sentences\");\n\nmodule.exports = class ShortSentencesView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload(params = {}) {\n    let vnode = template({\n      sentences: this._delegate.getCalculation(\"grammar.sentences\", params),\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      onCalculate: (params) => this.reload(params),\n      limit: 10\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\nconst Helpers = require(\"../helpers\");\n\nmodule.exports = function(input) {\n  let nullable = input.nullable;\n  let endable = input.endable;\n  let first = input.first;\n  let follow = input.follow;\n  let info = input.info;\n\n  return [\n    m(\"h1\", \"Nonterminals\"),\n\n    m(\"table.symbols\",\n      m(\"tr\",\n        m(\"th\", \"Symbol\"),\n        m(\"th\", \"Nullable?\"),\n        m(\"th\", \"Endable?\"),\n        m(\"th\", \"First set\"),\n        m(\"th\", \"Follow set\")\n      ),\n\n      info.productionOrder.map(function(symbol) {\n        let firstSymbols = first.get(symbol);\n        let followSymbols = follow.get(symbol);\n\n        return m(\"tr\",\n          m(\"td\", Helpers.formatSymbol(symbol, info)),\n          m(\"td\", nullable.has(symbol) ? \"Nullable\" : \"\"),\n          m(\"td\", endable.has(symbol) ? \"Endable\" : \"\"),\n          m(\"td\", Helpers.formatSymbolList(Helpers.listSymbols(firstSymbols, info.terminalOrder), info)),\n          m(\"td\", Helpers.formatSymbolList(Helpers.listSymbols(followSymbols, info.terminalOrder), info))\n        );\n      })\n    )\n  ];\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/nonterminals\");\n\nmodule.exports = class NonterminalsView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      nullable: this._delegate.getCalculation(\"grammar.nullable\"),\n      endable: this._delegate.getCalculation(\"grammar.endable\"),\n      first: this._delegate.getCalculation(\"grammar.first\"),\n      follow: this._delegate.getCalculation(\"grammar.follow\"),\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\n\nconst MDASH = \"\\u2014\";\n\nfunction formatClassification(cs, c, n) {\n  if (cs[c].member) {\n    return [\"The grammar is \", n, \".\"];\n  } else {\n    return m(\"span\", { className: \"conflict\" }, \"Not \", n, \" \", MDASH, \" \", cs[c].reason, \".\");\n  }\n}\n\nmodule.exports = function(input) {\n  let classification = input.classification;\n\n  return [\n    m(\"h1\", \"Parsing Algorithms\"),\n    m(\"table.parsing-algorithm-table\",\n      m(\"tr\",\n        m(\"th\", { scope: \"row\" }, \"LL(1)\"),\n        m(\"td.classification\", formatClassification(classification, \"ll1\", \"LL(1)\")),\n        m(\"td\",\n          m(\"a\", { href: \"#/ll1-table\" }, \"Parsing table\")\n        )\n      ),\n      m(\"tr\",\n        m(\"th\", { scope: \"row\" }, \"LR(0)\"),\n        m(\"td.classification\", formatClassification(classification, \"lr0\", \"LR(0)\")),\n        m(\"td\",\n          m(\"a\", { href: \"#/lr0-automaton\" }, \"Automaton\"),\n          \", \",\n          m(\"a\", { href: \"#/lr0-table\" }, \"Parsing table\")\n        )\n      ),\n      m(\"tr\",\n        m(\"th\", { scope: \"row\" }, \"SLR(1)\"),\n        m(\"td.classification\", formatClassification(classification, \"slr1\", \"SLR(1)\")),\n        m(\"td\",\n          m(\"a\", { href: \"#/slr1-table\" }, \"Parsing table\")\n        )\n      ),\n      m(\"tr\",\n        m(\"th\", { scope: \"row\" }, \"LR(1)\"),\n        m(\"td.classification\", formatClassification(classification, \"lr1\", \"LR(1)\")),\n        m(\"td\",\n          m(\"a\", { href: \"#/lr1-automaton\" }, \"Automaton\"),\n          \", \",\n          m(\"a\", { href: \"#/lr1-table\" }, \"Parsing table\")\n        )\n      ),\n      m(\"tr\",\n        m(\"th\", { scope: \"row\" }, \"LALR(1)\"),\n        m(\"td.classification\", formatClassification(classification, \"lalr1\", \"LALR(1)\")),\n        m(\"td\",\n          m(\"a\", { href: \"#/lalr1-automaton\" }, \"Automaton\"),\n          \", \",\n          m(\"a\", { href: \"#/lalr1-table\" }, \"Parsing table\")\n        )\n      )\n    )\n  ];\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/parsing\");\n\nmodule.exports = class ParsingView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      classification: this._delegate.getCalculation(\"grammar.classification\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\nconst END = require(\"../grammar/symbols\").END;\nconst Helpers = require(\"../helpers\");\n\nmodule.exports = function(input) {\n  let info = input.info;\n  let table = input.table;\n  let productions = input.productions;\n\n  return m(\"table.symbols.ll1-table\",\n    m(\"colgroup\",\n      m(\"col\")\n    ),\n    m(\"colgroup.t\",\n      Helpers.fillArray(info.terminals.size + 1, m(\"col\"))\n    ),\n\n    m(\"tr\",\n      m(\"th\"),\n      info.terminalOrder.map(function(symbol) {\n        return m(\"th\", Helpers.formatSymbol(symbol, info));\n      }),\n      m(\"th\", Helpers.formatSymbol(END, info))\n    ),\n\n    info.productionOrder.map(function(nt) {\n      return m(\"tr\",\n        m(\"th\", { scope: \"row\" }, Helpers.formatSymbol(nt, info)),\n        info.terminalOrder.concat(END).map(function(t) {\n          if (typeof table[nt][t] !== \"undefined\") {\n            return m(\"td\", { className: table[nt][t].length > 1 ? \"conflict\" : \"\" },\n              m(\"ul\",\n                table[nt][t].map(function(p) {\n                  return m(\"li\", Helpers.formatProduction(productions[p], info));\n                })\n              )\n            );\n          } else {\n            return m(\"td\");\n          }\n        })\n      );\n    })\n  );\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/ll1_table\");\n\nmodule.exports = class LL1TableView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      table: this._delegate.getCalculation(\"parsing.ll.ll1_table\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const Helpers = require(\"../helpers\");\n\nmodule.exports = function(input) {\n  let info = input.info;\n  let automaton = input.automaton;\n  let productions = input.productions;\n  let start = input.start;\n  let title = input.title;\n\n  let result = [];\n\n  result.push(\n    \"digraph \\\"\",\n    title,\n    \"\\\" {\\n  graph [rankdir=LR];\\n  node [shape=record];\\n\"\n  );\n\n  automaton.forEach(function(state, index) {\n    result.push(\n      \"  s\",\n      index,\n      \" [label=\\\"\",\n      index,\n      \" | \",\n      state.items.map(function(item) { return Helpers.bareFormatItem(item, start, productions, info); }).join(\"\\\\n\"),\n      \"\\\"];\\n\"\n    );\n  });\n\n  automaton.forEach(function(state, index) {\n    var s;\n    for (s in state.transitions) {\n      result.push(\n        \"  s\",\n        index,\n        \" -> s\",\n        state.transitions[s],\n        \" [label=\\\"\",\n        Helpers.bareFormatSymbol(s, input.info),\n        \"\\\"];\\n\"\n      );\n    }\n  });\n\n  result.push(\"}\\n\");\n\n  return result.join(\"\");\n}\n","const template = require(\"../templates/lr_automaton_graph\");\n\nmodule.exports = class LR0AutomatonView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let dot = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      automaton: this._delegate.getCalculation(\"parsing.lr.lr0_automaton\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\"),\n      start: this._delegate.getCalculation(\"grammar.start\"),\n      title: \"LR(0) Automaton\"\n    });\n\n    this._element.innerHTML = Viz(dot);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\nconst Helpers = require(\"../helpers\");\n\nmodule.exports = function(input) {\n  let info = input.info;\n  let table = input.table;\n  let productions = input.productions;\n\n  return m(\"table.symbols.lr0-table\",\n    m(\"colgroup\",\n      m(\"col\")\n    ),\n    m(\"colgroup.t\",\n      Helpers.fillArray(info.terminals.size, m(\"col\"))\n    ),\n    m(\"colgroup.nt\",\n      Helpers.fillArray(info.nonterminals.size, m(\"col\"))\n    ),\n\n    m(\"tr\",\n      m(\"th\", \"State\"),\n      info.terminalOrder.map(function(symbol) {\n        return m(\"th\", Helpers.formatSymbol(symbol, info));\n      }),\n      info.nonterminalOrder.map(function(symbol) {\n        return m(\"th\", Helpers.formatSymbol(symbol, info));\n      })\n    ),\n\n    table.map(function(state, index) {\n      return m(\"tr\",\n        m(\"th\", { scope: \"row\" }, index),\n        info.terminalOrder.map(function(s) {\n          let actions = [];\n\n          if (typeof state.shift[s] !== \"undefined\") {\n            actions.push(m(\"li\", \"shift(\", state.shift[s], \")\"));\n          }\n\n          state.reduce.forEach(function(p) {\n            if (p === -1) {\n              actions.push(m(\"li\", \"accept\"));\n            } else {\n              actions.push(m(\"li\", \"reduce(\", Helpers.formatProduction(productions[p], info), \")\"));\n            }\n          });\n\n          let isConflict = (typeof state.shift[s] === \"undefined\" ? 0 : 1) + state.reduce.length > 1;\n\n          return m(\"td\", { className: isConflict ? \"conflict\" : \"\" },\n            m(\"ul\", actions)\n          );\n        }),\n\n        info.nonterminalOrder.map(function(s) {\n          return m(\"td\",\n            m(\"ul\", typeof state.shift[s] !== \"undefined\" ? m(\"li\", state.shift[s]) : [])\n          );\n        })\n      );\n    })\n  );\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/lr0_table\");\n\nmodule.exports = class LR0TableView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      table: this._delegate.getCalculation(\"parsing.lr.lr0_table\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\nconst END = require(\"../grammar/symbols\").END;\nconst Helpers = require(\"../helpers\");\n\nmodule.exports = function(input) {\n  let info = input.info;\n  let table = input.table;\n  let productions = input.productions;\n\n  return m(\"table.symbols.lr1-table\",\n    m(\"colgroup\",\n      m(\"col\")\n    ),\n    m(\"colgroup.t\",\n      Helpers.fillArray(info.terminals.size + 1, m(\"col\"))\n    ),\n    m(\"colgroup.nt\",\n      Helpers.fillArray(info.nonterminals.size, m(\"col\"))\n    ),\n\n    m(\"tr\",\n      m(\"th\", \"State\"),\n      info.terminalOrder.map(function(symbol) {\n        return m(\"th\", Helpers.formatSymbol(symbol, info));\n      }),\n      m(\"th\", Helpers.formatSymbol(END, info)),\n      info.nonterminalOrder.map(function(symbol) {\n        return m(\"th\", Helpers.formatSymbol(symbol, info));\n      })\n    ),\n\n    table.map(function(state, index) {\n      return m(\"tr\",\n        m(\"th\", { scope: \"row\" }, index),\n        info.terminalOrder.concat(END).map(function(s) {\n          if (typeof state[s] === \"undefined\") {\n            return m(\"td\");\n          } else {\n            let actions = [];\n\n            if (typeof state[s].shift !== \"undefined\") {\n              actions.push(m(\"li\", \"shift(\", state[s].shift, \")\"));\n            }\n\n            if (typeof state[s].reduce !== \"undefined\") {\n              state[s].reduce.forEach(function(p) {\n                if (p === -1) {\n                  actions.push(m(\"li\", \"accept\"));\n                } else {\n                  actions.push(m(\"li\", \"reduce(\", Helpers.formatProduction(productions[p], info), \")\"));\n                }\n              });\n            }\n\n            let isConflict = (typeof state[s].shift === \"undefined\" ? 0 : 1) + (typeof state[s].reduce !== \"undefined\" ? state[s].reduce.length : 0) > 1;\n\n            return m(\"td\", { className: isConflict ? \"conflict\" : \"\" },\n              m(\"ul\", actions)\n            );\n          }\n        }),\n        info.nonterminalOrder.map(function(s) {\n          if (typeof state[s] === \"undefined\") {\n            return m(\"td\");\n          } else if (typeof state[s].shift === \"undefined\") {\n            return m(\"td\",\n              m(\"ul\")\n            );\n          } else {\n            return m(\"td\",\n              m(\"ul\",\n                m(\"li\", state[s].shift)\n              )\n            );\n          }\n        })\n      );\n    })\n  );\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/lr1_table\");\n\nmodule.exports = class SLR1TableView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      table: this._delegate.getCalculation(\"parsing.lr.slr1_table\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const template = require(\"../templates/lr_automaton_graph\");\n\nmodule.exports = class LR1AutomatonView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let dot = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      automaton: this._delegate.getCalculation(\"parsing.lr.lr1_automaton\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\"),\n      start: this._delegate.getCalculation(\"grammar.start\"),\n      title: \"LR(1) Automaton\"\n    });\n\n    this._element.innerHTML = Viz(dot);\n  }\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/lr1_table\");\n\nmodule.exports = class LR1TableView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      table: this._delegate.getCalculation(\"parsing.lr.lr1_table\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const template = require(\"../templates/lr_automaton_graph\");\n\nmodule.exports = class LALR1AutomatonView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let dot = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      automaton: this._delegate.getCalculation(\"parsing.lr.lalr1_automaton\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\"),\n      start: this._delegate.getCalculation(\"grammar.start\"),\n      title: \"LALR(1) Automaton\"\n    });\n\n    this._element.innerHTML = Viz(dot);\n  }\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/lr1_table\");\n\nmodule.exports = class LALR1TableView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      info: this._delegate.getCalculation(\"grammar.symbolInfo\"),\n      table: this._delegate.getCalculation(\"parsing.lr.lalr1_table\"),\n      productions: this._delegate.getCalculation(\"grammar.productions\")\n    });\n\n    render(this._element, vnode);\n  }\n}\n","var HeaderView = require(\"../views/header_view\");\nvar BlankSlateView = require(\"../views/blank_slate_view\");\nvar SanityView = require(\"../views/sanity_view\");\nvar SentencesView = require(\"../views/sentences_view\");\nvar ShortSentencesView = require(\"../views/short_sentences_view\");\nvar NonterminalsView = require(\"../views/nonterminals_view\");\nvar ParsingView = require(\"../views/parsing_view\");\nvar LL1TableView = require(\"../views/ll1_table_view\");\nvar LR0AutomatonView = require(\"../views/lr0_automaton_view\");\nvar LR0TableView = require(\"../views/lr0_table_view\");\nvar SLR1TableView = require(\"../views/slr1_table_view\");\nvar LR1AutomatonView = require(\"../views/lr1_automaton_view\");\nvar LR1TableView = require(\"../views/lr1_table_view\");\nvar LALR1AutomatonView = require(\"../views/lalr1_automaton_view\");\nvar LALR1TableView = require(\"../views/lalr1_table_view\");\n\nmodule.exports = class AnalysisController {\n  constructor(element) {\n\n    this._element = element;\n    this._element.id = \"analysis\";\n\n    // blank slate view\n\n    this._blankSlateElement = document.createElement(\"section\");\n    this._element.appendChild(this._blankSlateElement);\n\n    this._blankSlateView = new BlankSlateView(this._blankSlateElement);\n    this._blankSlateView.setDelegate(this);\n\n    // header view (managed separately from views which are swapped\n    // depending on routes)\n\n    this._headerElement = document.createElement(\"header\");\n    this._element.appendChild(this._headerElement);\n\n    this._headerView = new HeaderView(this._headerElement);\n    this._headerView.setDelegate(this);\n\n    // routes\n\n    this._routes = {\n\n      \"/\": {\n        views: [\n          { id: \"sanity\", constructor: SanityView },\n          { id: \"sentences\", constructor: ShortSentencesView },\n          { id: \"nonterminals\", constructor: NonterminalsView },\n          { id: \"parsing\", constructor: ParsingView }\n        ],\n        path: [{ title: \"Analysis\" }]\n      },\n\n      \"/ll1-table\": {\n        views: [\n          { id: \"table\", constructor: LL1TableView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LL(1) Parsing Table\" }]\n      },\n\n      \"/lr0-automaton\": {\n        views: [\n          { id: \"automaton\", constructor: LR0AutomatonView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LR(0) Automaton\" }]\n      },\n\n      \"/lr0-table\": {\n        views: [\n          { id: \"table\", constructor: LR0TableView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LR(0) Parsing Table\" }]\n      },\n\n      \"/slr1-table\": {\n        views: [\n          { id: \"table\", constructor: SLR1TableView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"SLR(1) Parsing Table\" }]\n      },\n\n      \"/lr1-automaton\": {\n        views: [\n          { id: \"automaton\", constructor: LR1AutomatonView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LR(1) Automaton\" }]\n      },\n\n      \"/lr1-table\": {\n        views: [\n          { id: \"table\", constructor: LR1TableView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LR(1) Parsing Table\" }]\n      },\n\n      \"/lalr1-automaton\": {\n        views: [\n          { id: \"automaton\", constructor: LALR1AutomatonView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LALR(1) Automaton\" }]\n      },\n\n      \"/lalr1-table\": {\n        views: [\n          { id: \"table\", constructor: LALR1TableView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"LALR(1) Parsing Table\" }]\n      },\n\n      \"/sentences\": {\n        views: [\n          { id: \"sentences\", constructor: SentencesView }\n        ],\n        path: [{ path: \"/\", title: \"Analysis\" }, { title: \"Example Sentences\" }]\n      }\n\n    };\n\n    // view (for routes)\n\n    this._views = [];\n\n  }\n\n  setDelegate(delegate) {\n\n    this._delegate = delegate;\n\n  }\n\n  reload() {\n\n    var i;\n    var path, pathChanged;\n\n    // get grammar and path\n\n    this._grammar = this._delegate.getGrammar();\n\n    path = this._delegate.getPath();\n    pathChanged = path !== this._path;\n    this._path = path;\n\n    // if we have views, clear them\n\n    if (this._views.length > 0) {\n\n      for (i = 0; i < this._views.length; i++) {\n        if (this._views[i].instance.teardown) {\n          this._views[i].instance.teardown();\n        }\n\n        this._element.removeChild(this._views[i].element);\n      }\n\n      this._views = [];\n\n    }\n\n    // if the grammar is defined, create views\n\n    if (typeof this._grammar !== \"undefined\") {\n\n      var route = this._routes[this._path];\n\n      for (i = 0; i < route.views.length; i++) {\n\n        var element = document.createElement(\"article\");\n        element.id = route.views[i].id;\n        this._element.appendChild(element);\n\n        var instance = new route.views[i].constructor(element);\n        instance.setDelegate(this);\n\n        if (instance.setup) {\n          instance.setup();\n        }\n\n        if (instance.reload) {\n          instance.reload();\n        }\n\n        this._views[i] = {\n          instance: instance,\n          element: element\n        };\n\n      }\n\n      this._headerElement.style.display = '';\n      this._blankSlateElement.style.display = 'none';\n\n    } else {\n\n      this._headerElement.style.display = 'none';\n      this._blankSlateElement.style.display = '';\n\n    }\n\n    this._headerView.reload();\n    this._blankSlateView.reload();\n\n    // possibly reset scroll to top-left\n\n    if (pathChanged) {\n\n      this._element.scrollLeft = 0;\n      this._element.scrollTop = 0;\n\n    }\n\n  }\n\n  getCalculation(name, params = {}) {\n\n    return this._grammar.calculate(name, params);\n  }\n\n  getPathComponents() {\n\n    return this._routes[this._path].path;\n\n  }\n}\n","const m = require(\"mithril/hyperscript\");\n\nmodule.exports = function(input) {\n  let spec = input.spec;\n\n  return m(\"div.spec-wrap\",\n    m(\"textarea.spec\", { value: spec })\n  );\n};\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/edit\");\n\nmodule.exports = class EditController {\n  constructor(element) {\n    this._element = element;\n    this._element.id = \"edit\";\n  }\n\n  getSpec() {\n    return this._element.querySelector(\".spec\").value;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      spec: this._delegate.getSpec()\n    });\n\n    render(this._element, vnode);\n  }\n}\n","const m = require(\"mithril/hyperscript\");\nconst Helpers = require(\"../helpers\");\nconst formatTransformation = require(\"../helpers\").formatTransformation;\n\nmodule.exports = function(input) {\n  let productions = input.productions;\n  let info = input.info;\n  let undoTransformation = input.undoTransformation;\n  let redoTransformation = input.redoTransformation;\n  let transformations = input.transformations;\n\n  let buttons = [];\n\n  if (typeof undoTransformation !== \"undefined\") {\n    buttons.push(\n      m(\"button.undo\", { \"data-action\": \"undo\" },\n        \"Undo \",\n        formatTransformation(undoTransformation, productions, info)\n      )\n    );\n  }\n\n  if (typeof redoTransformation !== \"undefined\") {\n    buttons.push(\n      m(\"button.redo\", { \"data-action\": \"redo\" },\n        \"Redo \",\n        formatTransformation(redoTransformation, productions, info)\n      )\n    );\n  }\n\n  let productionTransformations = [];\n\n  for (let i = 0; i < productions.length; i++) {\n    productionTransformations[i] = [];\n    for (let j = 0; j < productions[i].length; j++) {\n      productionTransformations[i][j] = [];\n    }\n  }\n\n  for (let i = 0; i < transformations.length; i++) {\n    let transformation = transformations[i];\n    productionTransformations[transformation.production][transformation.symbol].push({\n      index: i,\n      transformation: transformation\n    });\n  }\n\n  return [\n    m(\"div.buttons\", buttons),\n\n    m(\"table.symbols.productions\",\n      productions.map(function(production, i) {\n        let result = [];\n\n        production.forEach(function(symbol, j) {\n          if (j > 0) {\n            result.push(\" \");\n          }\n\n          if (productionTransformations[i][j].length > 0) {\n            result.push(\n              m(\"span.pill\",\n                Helpers.formatSymbol(symbol, info),\n                m(\"select\",\n                  m(\"option\", { disabled: true, selected: true }, symbol),\n                  productionTransformations[i][j].map(function(t) {\n                    return m(\"option\", { value: t.index },\n                      formatTransformation(t.transformation, productions, info)\n                    );\n                  })\n                )\n              )\n            );\n          } else {\n            result.push(Helpers.formatSymbol(symbol, info));\n          }\n\n          if (j === 0) {\n            result.push(\" \");\n            result.push(\"\\u2192\"); // arrow\n          }\n        });\n\n        if (production.length === 1) {\n          result.push(\" \");\n          result.push(m(\"u\", \"\\u03B5\")); // epsilon\n        }\n\n        return m(\"tr\",\n          m(\"td\", result)\n        );\n      })\n    )\n  ];\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/transform\");\n\nmodule.exports = class TransformView {\n  constructor(element) {\n    this._element = element;\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  setup() {\n    this._element.addEventListener(\"click\", function(e) {\n      if (e.target.dataset.action === \"undo\") {\n        this._delegate.undo();\n      } else if (e.target.dataset.action === \"redo\") {\n        this._delegate.redo();\n      }\n    }.bind(this));\n\n    this._element.addEventListener(\"change\", function(e) {\n      let index = parseInt(e.target.value);\n      this._delegate.transform(this._transformations[index]);\n    }.bind(this));\n  }\n\n  reload() {\n    this._transformations = this._delegate.getTransformations();\n\n    let vnode = template({\n      productions: this._delegate.getProductions(),\n      info: this._delegate.getSymbolInfo(),\n      undoTransformation: this._delegate.getUndoTransformation(),\n      redoTransformation: this._delegate.getRedoTransformation(),\n      transformations: this._transformations\n    });\n\n    render(this._element, vnode);\n  }\n\n}\n","var TransformView = require('../views/transform_view');\n\nmodule.exports = class TransformController {\n  constructor(element) {\n\n    this._element = element;\n    this._element.id = \"transform\";\n\n    this._transformElement = document.createElement(\"article\");\n    this._element.appendChild(this._transformElement);\n\n    this._transformView = new TransformView(this._transformElement);\n    this._transformView.setDelegate(this);\n\n    if (this._transformView.setup) {\n      this._transformView.setup();\n    }\n\n  }\n\n  setDelegate(delegate) {\n\n    this._delegate = delegate;\n\n  }\n\n  reload() {\n\n    this._index = 0;\n    this._stack = [ { grammar: this._delegate.getGrammar() } ];\n\n    this._transformView.reload();\n\n  }\n\n  getProductions() {\n\n    return this._stack[this._index].grammar.productions;\n\n  }\n\n  getSymbolInfo() {\n\n    return this._stack[this._index].grammar.calculate(\"grammar.symbolInfo\");\n\n  }\n\n  getPreviousSymbolInfo() {\n\n    if (this._index > 0) {\n      return this._stack[this._index - 1].grammar.calculate(\"grammar.symbolInfo\");\n    }\n\n  }\n\n  getTransformations(productionIndex, symbolIndex) {\n\n    return this._stack[this._index].grammar.calculate(\"transformations.all\");\n\n  }\n\n  getUndoTransformation() {\n\n    if (this._index > 0) {\n      return this._stack[this._index].transformation;\n    }\n\n  }\n\n  getRedoTransformation() {\n\n    if (this._index < this._stack.length - 1) {\n      return this._stack[this._index + 1].transformation;\n    }\n\n  }\n\n  undo() {\n\n    if (this._index > 0) {\n      this._index--;\n    }\n\n    this._transformView.reload();\n\n    this._delegate.grammarChanged(this._stack[this._index].grammar);\n\n  }\n\n  redo() {\n\n    if (this._index < this._stack.length - 1) {\n      this._index++;\n    }\n\n    this._transformView.reload();\n\n    this._delegate.grammarChanged(this._stack[this._index].grammar);\n\n  }\n\n  transform(transformation) {\n\n    var item = {\n      grammar: this._stack[this._index].grammar.transform(transformation),\n      transformation: transformation\n    };\n\n    this._index++;\n    this._stack.splice(this._index, this._stack.length - this._index, item);\n\n    this._transformView.reload();\n\n    this._delegate.grammarChanged(this._stack[this._index].grammar);\n\n  }\n}\n","const m = require(\"mithril/hyperscript\");\n\nmodule.exports = function(input) {\n  let mode = input.mode;\n\n  return [\n    m(\"input#mode-edit\", { type: \"radio\", name: \"mode\", value: \"edit\", checked: mode === \"edit\" }),\n    m(\"label.left\", { for: \"mode-edit\" }, \"Edit\"),\n    m(\"input#mode-transform\", { type: \"radio\", name: \"mode\", value: \"transform\", checked: mode === \"transform\" }),\n    m(\"label.right\", { for: \"mode-transform\" }, \"Transform\"),\n    m(\"button#mode-analyze\", { disabled: mode !== \"edit\" }, \"Analyze\")\n  ];\n}\n","const render = require(\"mithril/render\");\nconst template = require(\"../templates/mode\");\n\nmodule.exports = class ModeController {\n  constructor(element) {\n    this._element = element;\n    this._element.id = \"mode\";\n\n    this._element.addEventListener(\"change\", function(e) {\n      if (e.target.value === \"edit\") {\n        this._delegate.edit();\n      } else if (e.target.value === \"transform\") {\n        this._delegate.transform();\n      }\n    }.bind(this));\n\n    this._element.addEventListener(\"click\", function(e) {\n      if (e.target.id === \"mode-analyze\") {\n        this._delegate.analyze();\n      }\n    }.bind(this));\n  }\n\n  setDelegate(delegate) {\n    this._delegate = delegate;\n  }\n\n  reload() {\n    let vnode = template({\n      mode: this._delegate.getMode()\n    });\n\n    render(this._element, vnode);\n  }\n}\n","module.exports = function(grammar) {\n\n  return {\n    \"ll1\": grammar.calculate(\"parsing.ll.ll1_classification\"),\n    \"lr0\": grammar.calculate(\"parsing.lr.lr0_classification\"),\n    \"slr1\": grammar.calculate(\"parsing.lr.slr1_classification\"),\n    \"lr1\": grammar.calculate(\"parsing.lr.lr1_classification\"),\n    \"lalr1\": grammar.calculate(\"parsing.lr.lalr1_classification\")\n  };\n\n};\n","module.exports = function(grammar) {\n\n  var i;\n  var nonterminals = new Set();\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    nonterminals.add(grammar.productions[i][0]);\n  }\n\n  return nonterminals;\n\n};\n","module.exports = function(grammar) {\n\n  var i, j;\n  var terminals = new Set();\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    for (j = 1; j < grammar.productions[i].length; j++) {\n\n      if (!nonterminals.has(grammar.productions[i][j])) {\n        terminals.add(grammar.productions[i][j]);\n      }\n\n    }\n  }\n\n  return terminals;\n\n};\n","module.exports = function(grammar) {\n\n  var i, j, s;\n\n  var terminalOrder = [];\n  var nonterminalOrder = [];\n  var productionOrder = [];\n\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var terminals = grammar.calculate(\"grammar.terminals\");\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    s = grammar.productions[i][0];\n\n    if (productionOrder.indexOf(s) === -1) {\n      productionOrder.push(s);\n    }\n\n    for (j = 0; j < grammar.productions[i].length; j++) {\n\n      s = grammar.productions[i][j];\n\n      if (nonterminals.has(s) && nonterminalOrder.indexOf(s) === -1) {\n        nonterminalOrder.push(s);\n      }\n\n      if (terminals.has(s) && terminalOrder.indexOf(s) === -1) {\n        terminalOrder.push(s);\n      }\n\n    }\n\n  }\n\n  return {\n    terminalOrder: terminalOrder,\n    nonterminalOrder: nonterminalOrder,\n    productionOrder: productionOrder,\n\n    nonterminals: nonterminals,\n    terminals: terminals\n  };\n\n};\n","module.exports = function(grammar) {\n\n  return grammar.productions[0][0];\n\n};\n","module.exports = function(grammar) {\n\n  return grammar.productions;\n\n};\n","module.exports = class ErrorController {\n  constructor(element) {\n\n    this._element = element;\n    this._element.id = \"error\";\n\n  }\n\n  setDelegate(delegate) {\n\n    this._delegate = delegate;\n\n  }\n\n  reload() {\n\n    var error = this._delegate.getError();\n\n    if (typeof error !== \"undefined\") {\n      this._element.innerHTML = \"<code>\" + this._delegate.getError() + \"</code>\";\n    } else {\n      this._element.innerHTML = \"\";\n    }\n\n  }\n}\n","class Relation {\n  constructor(iterable) {\n    this._map = new Map();\n\n    if (iterable != null) {\n      for (let [s, t] of iterable) {\n        this.add(s, t);\n      }\n    }\n  }\n\n  has(s, t) {\n    if (this._map.has(s)) {\n      return this._map.get(s).has(t);\n    } else {\n      return false;\n    }\n  }\n\n  get(s) {\n    if (this._map.has(s)) {\n      return this._map.get(s);\n    } else {\n      return new Set();\n    }\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  *[Symbol.iterator]() {\n    for (let k of this._map.keys()) {\n      for (let l of this._map.get(k)) {\n        yield [k, l];\n      }\n    }\n  }\n\n  entries() {\n    return this[Symbol.iterator]();\n  }\n\n  add(s, t) {\n    if (!this._map.has(s)) {\n      this._map.set(s, new Set());\n    }\n\n    this._map.get(s).add(t);\n  }\n\n  propagate(propagation) {\n    let result = new Relation();\n    let closed = propagation.closure();\n\n    for (let k of this.keys()) {\n      for (let l of this.get(k)) {\n        result.add(k, l);\n      }\n    }\n\n    for (let s of closed.keys()) {\n      for (let t of closed.get(s)) {\n        for (let u of this.get(t)) {\n          result.add(s, u);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  closure() {\n    var result = new Relation();\n    var keys = new Set();\n\n    // Copy the relation and build the set of keys\n\n    for (let i of this.keys()) {\n      keys.add(i);\n\n      for (let j of this.get(i)) {\n        keys.add(j);\n\n        result.add(i, j);\n      }\n    }\n\n    // Perform transitive closure\n\n    for (let k of keys) {\n      for (let i of keys) {\n        for (let j of keys) {\n          if (result.has(i, j) || (result.has(i, k) && result.has(k, j))) {\n            result.add(i, j);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  dfs(k, v) {\n    for (let l of this.get(k)) {\n      if (v.indexOf(l) != -1) {\n        if (l == k) {\n          return v.concat(k);\n        } else {\n          return v.concat(k).concat(l);\n        }\n      }\n\n      let w = this.dfs(l, v.concat(k));\n      if (w) {\n        return w;\n      }\n    }\n\n    return undefined;\n  }\n\n  cycle() {\n    for (let k of this.keys()) {\n      let v = this.dfs(k, []);\n      if (v) {\n        return v;\n      }\n    }\n\n    return undefined;\n  }\n}\n\nmodule.exports = Relation;\n","var Relation = require('../../../relation');\n\nmodule.exports = function(grammar) {\n\n  var relation, closure, unreachable;\n  var i, j, s;\n\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var start = grammar.calculate(\"grammar.start\");\n\n  // Build relation:\n  // (x,y) | x -> a y b where a and b are strings of terminals or nonterminals\n\n  relation = new Relation();\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    for (j = 1; j < grammar.productions[i].length; j++) {\n\n      if (nonterminals.has(grammar.productions[i][j])) {\n        relation.add(grammar.productions[i][0], grammar.productions[i][j]);\n      }\n\n    }\n  }\n\n  // Obtain the closure of the relation\n\n  closure = relation.closure();\n\n  // Collect unreachable nonterminals\n\n  unreachable = new Set();\n\n  for (s of nonterminals) {\n\n    if (s != start && (!closure.has(start, s))) {\n      unreachable.add(s);\n    }\n\n  }\n\n  return unreachable;\n\n};\n","module.exports = function(grammar) {\n\n  var marked, added, unrealizable;\n  var i, j, s;\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n\n  // Is a particular nonterminal realizable?\n\n  marked = new Set();\n\n  do {\n\n    added = [];\n\n    for (i = 0; i < grammar.productions.length; i++) {\n\n      // Are there any unmarked nonterminals? Break at the first one.\n\n      for (j = 1; j < grammar.productions[i].length; j++) {\n\n        if (!marked.has(grammar.productions[i][j]) && nonterminals.has(grammar.productions[i][j])) {\n          break;\n        }\n\n      }\n\n      // If the head of this production is not marked, and all of the symbols in\n      // the body of the production were not unmarked nonterminals (ie, they were\n      // either marked or terminals), mark the head and record\n      // that we marked it in this step.\n\n      if (!marked.has(grammar.productions[i][0]) && j == grammar.productions[i].length) {\n        marked.add(grammar.productions[i][0]);\n        added.push(grammar.productions[i][0]);\n      }\n\n    }\n\n  } while (added.length > 0);\n\n  // Collect nonterminals which were not marked.\n\n  unrealizable = new Set();\n\n  for (s of nonterminals) {\n\n    if (!marked.has(s)) {\n      unrealizable.add(s);\n    }\n\n  }\n\n  return unrealizable;\n\n};\n","const Relation = require(\"../../../relation\");\n\nmodule.exports = function(grammar) {\n\n  var relation;\n  var i, j, k;\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var nullable = grammar.calculate(\"grammar.nullable\");\n\n  // Build relation\n  // (x,y) | x -> a y b, y a nonterminal, a and b nullable\n\n  relation = new Relation();\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    for (j = 1; j < grammar.productions[i].length; j++) {\n\n      if (nonterminals.has(grammar.productions[i][j])) {\n\n        for (k = 1; k < grammar.productions[i].length; k++) {\n\n          if (j === k) {\n            continue;\n          }\n\n          if (!nonterminals.has(grammar.productions[i][k]) || !nullable.has(grammar.productions[i][k])) {\n            break;\n          }\n\n        }\n\n        if (k === grammar.productions[i].length) {\n          relation.add(grammar.productions[i][0], grammar.productions[i][j]);\n        }\n\n      }\n\n    }\n  }\n\n  // Find a cycle if there is one\n\n  return relation.cycle();\n\n};\n","module.exports = function(grammar) {\n\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var nullable = grammar.calculate(\"grammar.nullable\");\n  var found;\n  var nt;\n  var i, j;\n\n  // For each nonterminal...\n\n  for (nt of nonterminals) {\n\n    // Look through the productions of this nonterminal for\n    // productions which are nullable. If we find more than\n    // one, return them as an array (in order).\n\n    found = undefined;\n\n    for (i = 0; i < grammar.productions.length; i++) {\n\n      if (grammar.productions[i][0] == nt) {\n\n        // An empty production is nullable.\n\n        if (grammar.productions[i].length == 1) {\n\n          if (typeof found !== \"undefined\") {\n            return i < found ? [i, found] : [found, i];\n          } else {\n            found = i;\n          }\n\n          continue;\n\n        }\n\n        // A production is nullable if all of its symbols are nullable.\n\n        for (j = 1; j < grammar.productions[i].length; j++) {\n\n          if (!nullable.has(grammar.productions[i][j])) {\n            break;\n          }\n\n        }\n\n        if (j == grammar.productions[i].length) {\n\n          if (typeof found !== \"undefined\") {\n            return i < found ? [i, found] : [found, i];\n          } else {\n            found = i;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return [];\n\n};\n","module.exports = function(grammar) {\n\n  var nullable = new Set();\n  var added;\n  var i, j, head;\n\n  do {\n\n    added = [];\n\n    for (i = 0; i < grammar.productions.length; i++) {\n\n      for (j = 1; j < grammar.productions[i].length; j++) {\n        if (!nullable.has(grammar.productions[i][j])) {\n          break;\n        }\n      }\n\n      head = grammar.productions[i][0];\n\n      if (j == grammar.productions[i].length && !nullable.has(head)) {\n        nullable.add(head);\n        added.push(head);\n      }\n\n    }\n\n  } while (added.length > 0);\n\n  return nullable;\n\n};\n","var Relation = require('../../../relation');\n\nmodule.exports = function(grammar) {\n\n  var immediate, propagation, result;\n  var i, j;\n  var nullable = grammar.calculate(\"grammar.nullable\");\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n\n  immediate = new Relation();\n  propagation = new Relation();\n\n  // For each production, add the first terminal symbol after a sequence of nullable symbols.\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    // Skip nullable symbols...\n\n    for (j = 1; j < grammar.productions[i].length; j++) {\n\n      if (!nullable.has(grammar.productions[i][j])) {\n        break;\n      }\n\n    }\n\n    // If the first non-nullable symbol is a terminal, add it to the immediate first set\n    // of this nonterminal.\n\n    if (j < grammar.productions[i].length && !nonterminals.has(grammar.productions[i][j])) {\n      immediate.add(grammar.productions[i][0], grammar.productions[i][j]);\n    }\n\n  }\n\n  // For each production, add the prefix of nullable nonterminals, and then the next symbol\n  // if it is also a nonterminal.\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    for (j = 1; j < grammar.productions[i].length; j++) {\n\n      // Is it a nonterminal? Add it.\n\n      if (nonterminals.has(grammar.productions[i][j])) {\n        propagation.add(grammar.productions[i][0], grammar.productions[i][j]);\n      }\n\n      // Is it not nullable? Stop.\n\n      if (!nullable.has(grammar.productions[i][j])) {\n        break;\n      }\n\n    }\n  }\n\n  // Propagate the relation.\n\n  result = immediate.propagate(propagation);\n\n  return result;\n\n};\n","var Relation = require('../../../relation');\nvar END = require(\"../../symbols\").END;\n\nmodule.exports = function(grammar) {\n\n  var immediate, propagation, result;\n  var i, j, k, s;\n  var first = grammar.calculate(\"grammar.first\");\n  var nullable = grammar.calculate(\"grammar.nullable\");\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var start = grammar.calculate(\"grammar.start\");\n\n  immediate = new Relation();\n  propagation = new Relation();\n\n  // Add the end of input symbol to the immediate follow set of the grammar's start symbol.\n\n  immediate.add(start, END);\n\n  // Given a production X -> ... A β, follow(A) includes first(β), except for the empty string.\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    for (j = 1; j < grammar.productions[i].length - 1; j++) {\n\n      // If the symbol is a nonterminal...\n\n      if (nonterminals.has(grammar.productions[i][j])) {\n\n        // Add the first set of the remaining symbols to the follow set of the symbol\n\n        for (k = j + 1; k < grammar.productions[i].length; k++) {\n\n          // If this symbol is a terminal, add it, and then stop adding.\n\n          if (!nonterminals.has(grammar.productions[i][k])) {\n            immediate.add(grammar.productions[i][j], grammar.productions[i][k]);\n            break;\n          }\n\n          // If it is a nonterminal, add the first set of that nonterminal.\n\n          for (s of first.get(grammar.productions[i][k])) {\n            immediate.add(grammar.productions[i][j], s);\n          }\n\n          // Stop if it isn't nullable.\n\n          if (!nullable.has(grammar.productions[i][k])) {\n            break;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  // Given a production B -> ... A β where β is nullable or is the empty string, follow(A) includes follow(B)\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    // Scan from the end of the right side of the production to the beginning...\n\n    for (j = grammar.productions[i].length - 1; j > 0; j--) {\n\n      // If the symbol is a nonterminal, add the left side.\n\n      if (nonterminals.has(grammar.productions[i][j])) {\n        propagation.add(grammar.productions[i][j], grammar.productions[i][0]);\n      }\n\n      // If it isn't nullable, stop.\n\n      if (!nullable.has(grammar.productions[i][j])) {\n        break;\n      }\n\n    }\n\n  }\n\n  // Propagate the relation\n\n  result = immediate.propagate(propagation);\n\n  return result;\n\n};\n","const END = require(\"../../symbols\").END;\n\nmodule.exports = function(grammar) {\n\n  var s;\n  var endable = new Set();\n  var follow = grammar.calculate(\"grammar.follow\");\n\n  for (s of follow.keys()) {\n    if (follow.has(s, END)) {\n      endable.add(s);\n    }\n  }\n\n  return endable;\n\n};\n","// Given a \"sentence node\" and a grammar, expand the sentence's first\n// realizable nonterminal and return the resulting list of sentence nodes\n// (which may be empty).\n//\n// Each sentence node's \"step\" member is incremented and its \"nonterminals\"\n// member adjusted.\n\nfunction expandSentenceNode(node, grammar) {\n\n  var i, j, k;\n  var expanded = [];\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var unrealizable = grammar.calculate(\"grammar.unrealizable\");\n  var replacement, nonterminalCount;\n\n  // expand the first realizable nonterminal.\n\n  for (i = 0; i < node.sentence.length; i++) {\n\n    if (nonterminals.has(node.sentence[i]) && !unrealizable.has(node.sentence[i])) {\n\n      for (j = 0; j < grammar.productions.length; j++) {\n\n        if (grammar.productions[j][0] === node.sentence[i]) {\n\n          replacement = grammar.productions[j].slice(1);\n          nonterminalCount = 0;\n\n          for (k = 0; k < replacement.length; k++) {\n            if (nonterminals.has(replacement[k])) {\n              nonterminalCount++;\n            }\n          }\n\n          expanded.push({\n            sentence: node.sentence.slice(0, i).concat(replacement).concat(node.sentence.slice(i+1)),\n            steps: node.steps + 1,\n            nonterminals: node.nonterminals - 1 + nonterminalCount\n          });\n\n        }\n\n      }\n\n      break;\n\n    }\n\n  }\n\n  return expanded;\n\n}\n\nmodule.exports = function(grammar, input = {}) {\n  let params = {\n    maxSentences: 100,\n    maxDepth: 200,\n  };\n\n  if (input.maxSentences) {\n    params.maxSentences = input.maxSentences;\n  }\n  if (input.maxDepth) {\n    params.maxDepth = input.maxDepth;\n  }\n\n\n  var start = grammar.calculate(\"grammar.start\");\n\n  var i;\n  var sentences = [];\n  var queue = [{ sentence: [start], steps: 0, nonterminals: 1 }];\n  var node;\n  var expanded;\n\n  do {\n\n    node = queue.shift();\n    expanded = expandSentenceNode(node, grammar);\n\n    for (i = 0; i < expanded.length; i++) {\n\n      if (expanded[i].nonterminals === 0) {\n        sentences.push(expanded[i].sentence);\n      } else {\n        queue.push(expanded[i]);\n      }\n\n      if (sentences.length >= params.maxSentences) {\n        break;\n      }\n\n    }\n\n    // Sort the queue so that the next sentence is the one with the\n    // fewest nonterminals and steps.\n\n    queue = queue.sort(function(a, b) {\n      return (a.nonterminals + a.steps) - (b.nonterminals + b.steps);\n    });\n\n  } while (queue.length > 0 && sentences.length < params.maxSentences && queue.length < params.maxDepth);\n\n  return sentences.sort(function(a, b) {\n    if (a.length === b.length) {\n      return a < b;\n    } else {\n      return a.length - b.length;\n    }\n  });\n\n};\n","module.exports = function(grammar) {\n\n  var i, j;\n  var sentences = grammar.calculate(\"grammar.sentences\");\n\n  for (i = 0; i < sentences.length - 1; i++) {\n    if (sentences[i].length != sentences[i+1].length) {\n      continue;\n    }\n\n    for (j = 0; j < sentences[i].length; j++) {\n      if (sentences[i][j] !== sentences[i+1][j]) {\n        break;\n      }\n    }\n\n    if (j === sentences[i].length) {\n      return sentences[i];\n    }\n  }\n\n}\n","var SetOperations = require(\"../../../../set_operations\");\n\nmodule.exports = function(grammar) {\n\n  var i, k, l, s;\n  var head, body, first;\n\n  var nullAmbiguity = grammar.calculate(\"grammar.nullAmbiguity\");\n\n  // We can return immediately if the grammar contains a null ambiguity.\n\n  if (nullAmbiguity.length > 0) {\n    return { member: false, reason: \"it contains a null ambiguity\" };\n  }\n\n  var follow = grammar.calculate(\"grammar.follow\");\n  var terminals = grammar.calculate(\"grammar.terminals\");\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var nullable = grammar.calculate(\"grammar.nullable\");\n\n  // Check for first set clashes. Instead of checking intersections of\n  // first sets of all productions alpha_i for a given nonterminal A,\n  // set the [A, a] entry of a table for every a in first(alpha_i) for\n  // all A and alpha_i in A -> alpha_1 | alpha_2 | ... | alpha_n. If we\n  // come upon an entry that has already been set, there is a first\n  // set clash.\n\n  var table = {};\n\n  for (k of nonterminals) {\n\n    table[k] = {};\n\n    for (l of terminals) {\n      table[k][l] = false;\n    }\n\n  }\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    head = grammar.productions[i][0];\n    body = grammar.productions[i].slice(1);\n\n    first = grammar.getFirst(body);\n\n    for (s of first) {\n      if (table[head][s]) {\n        return { member: false, reason: \"it contains a first set clash\" };\n      }\n\n      table[head][s] = true;\n    }\n\n  }\n\n  // Check for first/follow set clashes. That is, check that every nullable\n  // production has disjoint first and follow sets.\n\n  first = grammar.calculate(\"grammar.first\");\n\n  for (k of nullable) {\n    if (SetOperations.any(SetOperations.intersection(first.get(k), follow.get(k)))) {\n      return { member: false, reason: \"it contains a first/follow set clash\" };\n    }\n\n  }\n\n  return { member: true };\n\n}\n","var END = require(\"../../../symbols\").END;\n\nmodule.exports = function(grammar) {\n\n  var i, k, l, s;\n  var table = {};\n  var head, body, first;\n\n  var terminals = grammar.calculate(\"grammar.terminals\");\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var follow = grammar.calculate(\"grammar.follow\");\n\n  // Populate table with blank arrays\n\n  for (k of nonterminals) {\n\n    table[k] = {};\n\n    for (l of terminals) {\n      table[k][l] = [];\n    }\n\n    table[k][END] = [];\n\n  }\n\n  // Collect moves\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    head = grammar.productions[i][0];\n    body = grammar.productions[i].slice(1);\n\n    // Get the first set of the production's body\n\n    first = grammar.getFirst(body);\n\n    // For each symbol s in first(body), add the production\n    // to table[nonterminal][s].\n\n    for (s of first) {\n      table[head][s].push(i);\n    }\n\n    // If the production is nullable, for each symbol s of follow(head),\n    // add this production to table[head][s].\n\n    if (grammar.isNullable(body)) {\n\n      for (s of follow.get(head)) {\n        table[head][s].push(i);\n      }\n\n    }\n\n  }\n\n  return table;\n\n};\n","module.exports = function(grammar) {\n\n  var i, s;\n  var table = grammar.calculate(\"parsing.lr.lr0_table\");\n  var terminals = grammar.calculate(\"grammar.terminals\");\n\n  for (i = 0; i < table.length; i++) {\n\n    if (table[i].reduce.length > 1) {\n      return { member: false, reason: \"it contains a reduce-reduce conflict\" };\n    }\n\n    if (table[i].reduce.length > 0) {\n      for (s in table[i].shift) {\n        if (terminals.has(s)) {\n          return { member: false, reason: \"it contains a shift-reduce conflict\" };\n        }\n      }\n    }\n\n  }\n\n  return { member: true };\n\n}\n","// Calculations for building LR(0), LR(1), SLR(1), and LALR(1)\n// automata and parsing tables.\n//\n// Automata are lists of states like this:\n//\n//   { kernel: [ ... ], items: [ ... ], transitions: { ... } }\n//\n// Items:\n//\n//   LR0: { production: -1, index: 0 }\n//   LR1: { production: -1, index: 0, lookahead: Grammar.END }\n//   LALR1: { production: -1, index: 0, lookaheads: [ Grammar.END, \"XYZ\" ] }\n//\n// Parsing tables are also lists of states, each of which are objects\n// representing the entries in the parsing table for that state.\n//\n// Rows for LR(0) parsing tables:\n//\n//   { shift: { ... }, reduce: [ ... ] }\n//\n// Examples:\n//\n//   { shift: { \"(\": 3, \"a\": 2, \"A\": 1 } }\n//   { reduce: -1 }\n//\n// -1 = augmented start state production.\n//\n// Rows for SLR(1), LR(1), and LALR(1) tables:\n//\n//   { \"symbol\": { shift: 6, reduce: [3] }, ... }\n//\n// Examples:\n//\n//   { \"else\": { shift: 6, reduce: [3] } }\n//   { \"if\": { shift: 4 }, \"other\": { shift: 3 }, \"S\": { shift: 7 }, \"I\": { shift: 2 } }\n\n// Build an LR automaton for the grammar, using the provided \"build\" functions.\n\nfunction automaton(grammar, build) {\n\n  var states = [ { kernel: build.initial() } ];\n\n  var state;\n  var l;\n  var s = 0;\n\n  var transitions, symbol, kernel;\n  var i;\n\n  // While no more states have been added... (outer loop)\n\n  while (s < states.length) {\n\n    // Process existing states... (inner loop)\n\n    for (l = states.length; s < l; s++) {\n\n      state = states[s];\n\n      // Find the closure of the state's kernel\n\n      state.items = build.closure(grammar, state.kernel);\n\n      // Find the transitions out of the state (a map from symbol to kernel)\n\n      transitions = build.transitions(grammar, state.items);\n\n      // Build the state's list of transitions...\n\n      state.transitions = {};\n\n      for (symbol in transitions) {\n\n        // Given a symbol and kernel in the transition map, find out if we've\n        // already added the kernel as a state. If we have, assign that state's\n        // index to the transition table for the symbol. If not, create a\n        // new state.\n\n        kernel = transitions[symbol];\n\n        for (i = 0; i < states.length; i++) {\n\n          if (build.same(states[i].kernel, kernel)) {\n            state.transitions[symbol] = i;\n            break;\n          }\n\n        }\n\n        if (i === states.length) {\n\n          state.transitions[symbol] = states.length;\n          states.push({ kernel: kernel });\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return states;\n\n}\n\nfunction classifyLR1(table) {\n\n  var i, s;\n\n  for (i = 0; i < table.length; i++) {\n\n    for (s in table[i]) {\n\n      if (typeof table[i][s].reduce !== \"undefined\" && table[i][s].reduce.length > 1) {\n        return { member: false, reason: \"it contains a reduce-reduce conflict\" };\n      }\n\n      if (typeof table[i][s].shift !== \"undefined\" && typeof table[i][s].reduce !== \"undefined\" && table[i][s].reduce.length > 0) {\n        return { member: false, reason: \"it contains a shift-reduce conflict\" };\n      }\n\n    }\n\n  }\n\n  return { member: true };\n\n}\n\nfunction addReduceAction(actions, symbol, production) {\n\n  if (typeof actions[symbol] === \"undefined\") {\n    actions[symbol] = { reduce: [] };\n  }\n\n  if (typeof actions[symbol].reduce === \"undefined\") {\n    actions[symbol].reduce = [];\n  }\n\n  actions[symbol].reduce.push(production);\n\n}\n\n// Collapse a list of LR1 items' lookaheads so that distinct\n// items' lookaheads are arrays.\n\nfunction collapseLookaheads(items) {\n\n  var i, p, x, l;\n  var table = {};\n\n  for (i = 0; i < items.length; i++) {\n\n    p = items[i].production;\n    x = items[i].index;\n    l = items[i].lookahead;\n\n    if (!table[p]) {\n      table[p] = [];\n    }\n\n    if (!table[p][x]) {\n      table[p][x] = [];\n    }\n\n    table[p][x].push(l);\n\n  }\n\n  var result = [];\n\n  for (p in table) {\n    for (x in table[p]) {\n      result.push({ production: parseInt(p), index: parseInt(x), lookaheads: table[p][x] });\n    }\n  }\n\n  return result;\n\n}\n\n// Return the union of the items in two LALR1 states.\n// For each item in the first state, add lookaheads from the second state's corresponding items.\n\nfunction mergeItems(a, b) {\n\n  var result = [];\n  var item;\n  var i, j, k;\n\n  for (i = 0; i < a.length; i++) {\n\n    item = { production: a[i].production, index: a[i].index, lookaheads: [] };\n\n    // Add lookaheads from a\n\n    for (j = 0; j < a[i].lookaheads.length; j++) {\n      item.lookaheads.push(a[i].lookaheads[j]);\n    }\n\n    // Find matching items in b and add their lookaheads if they aren't already present\n\n    for (j = 0; j < b.length; j++) {\n\n      if (b[j].production == a[i].production && b[j].index == a[i].index) {\n\n        for (k = 0; k < b[j].lookaheads.length; k++) {\n          if (item.lookaheads.indexOf(b[j].lookaheads[k]) === -1) {\n            item.lookaheads.push(b[j].lookaheads[k]);\n          }\n        }\n\n      }\n\n    }\n\n    result.push(item);\n\n  }\n\n  return result;\n\n}\n\nmodule.exports.automaton = automaton;\nmodule.exports.classifyLR1 = classifyLR1;\nmodule.exports.addReduceAction = addReduceAction;\nmodule.exports.collapseLookaheads = collapseLookaheads;\nmodule.exports.mergeItems = mergeItems;\n","var automaton = require(\"./helpers\").automaton;\nvar lr0 = require(\"./build/lr0\");\n\nmodule.exports = function(grammar) {\n\n  return automaton(grammar, lr0);\n\n}\n","module.exports = {\n\n  // What is the initial item?\n\n  initial: function() {\n\n    // production is an index into the grammar's list of productions,\n    // index is the distinguished position in that production,\n    // -1 is the production added by augmenting the grammar.\n\n    return [ { production: -1, index: 0 } ];\n\n  },\n\n  // Given an item's kernel, find its epsilon closure of items.\n\n  closure: function(grammar, kernel) {\n\n    var i, j;\n    var item, symbol;\n    var start = grammar.calculate(\"grammar.start\");\n\n    // Which items were added?\n\n    var added;\n\n    // Which productions have been used?\n\n    var used = new Set();\n\n    // Copy the kernel as the initial list of items\n\n    var result = [];\n\n    for (i = 0; i < kernel.length; i++) {\n      result.push({ production: kernel[i].production, index: kernel[i].index });\n    }\n\n    // While we cannot add more items...\n\n    do {\n\n      added = [];\n\n      // For each item we have...\n\n      for (i = 0; i < result.length; i++) {\n\n        // Find the nonterminal symbol...\n\n        item = result[i];\n\n        // If the production is the augmented start production, we're looking\n        // for the original start symbol. Otherwise, use the grammar's productions\n        // to find the symbol, but add one to account for the left-hand side of\n        // the production.\n\n        if (item.production === -1) {\n          symbol = [start][item.index];\n        } else {\n          symbol = grammar.productions[item.production][item.index + 1];\n        }\n\n        // Find unused matching productions and add them.\n\n        for (j = 0; j < grammar.productions.length; j++) {\n\n          if (!used.has(j) && grammar.productions[j][0] == symbol) {\n            added.push({ production: j, index: 0 });\n            used.add(j);\n          }\n\n        }\n\n      }\n\n      for (i = 0; i < added.length; i++) {\n        result.push(added[i]);\n      }\n\n    } while (added.length > 0);\n\n    return result;\n\n  },\n\n  // For the given list of (closure) items, return a map from symbol to kernel\n  // representing the transitions that can be taken out of the\n  // corresponding state.\n\n  transitions: function(grammar, closure) {\n\n    var result = {};\n    var i;\n    var item, symbol;\n    var start = grammar.calculate(\"grammar.start\");\n\n    // For each item...\n\n    for (i = 0; i < closure.length; i++) {\n\n      item = closure[i];\n\n      // Calculate the leaving symbol by looking in the grammar's productions,\n      // handling the augmented grammar production as above.\n\n      if (item.production === -1) {\n        symbol = [start][item.index];\n      } else {\n        symbol = grammar.productions[item.production][item.index + 1];\n      }\n\n      // If there is a leaving symbol, add the next item.\n\n      if (typeof symbol != \"undefined\") {\n\n        if (!result[symbol]) {\n          result[symbol] = [];\n        }\n\n        result[symbol].push({ production: item.production, index: item.index + 1 });\n\n      }\n\n    }\n\n    return result;\n\n  },\n\n  // Are the two kernels equal?\n\n  same: function(a, b) {\n\n    var i, j;\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n\n      for (j = 0; j < b.length; j++) {\n\n        if (a[i].production === b[j].production && a[i].index === b[j].index) {\n          break;\n        }\n\n      }\n\n      if (j === b.length) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n}\n","module.exports = function(grammar) {\n\n  var i, j, s;\n  var state, item, actions;\n  var table = [];\n  var automaton = grammar.calculate(\"parsing.lr.lr0_automaton\");\n\n  for (i = 0; i < automaton.length; i++) {\n\n    state = automaton[i];\n    actions = { shift: {}, reduce: [] };\n\n    // add shift actions for transitions\n\n    for (s in state.transitions) {\n      actions.shift[s] = state.transitions[s];\n    }\n\n    // add reduce actions for completed items\n\n    for (j = 0; j < state.items.length; j++) {\n\n      item = state.items[j];\n\n      if (item.production === -1) {\n        if (item.index === 1) {\n          actions.reduce.push(item.production);\n        }\n      } else {\n        if (item.index == grammar.productions[item.production].length - 1) {\n          actions.reduce.push(item.production);\n        }\n      }\n\n    }\n\n    table.push(actions);\n\n  }\n\n  return table;\n\n}\n","var classifyLR1 = require(\"./helpers\").classifyLR1;\n\nmodule.exports = function(grammar) {\n\n  return classifyLR1(grammar.calculate(\"parsing.lr.slr1_table\"));\n\n}\n","var END = require(\"../../../symbols\").END;\nvar addReduceAction = require(\"./helpers\").addReduceAction;\n\nmodule.exports = function(grammar) {\n\n  var i, j, s;\n  var state, actions, item;\n  var table = [];\n  var automaton = grammar.calculate(\"parsing.lr.lr0_automaton\");\n  var follow = grammar.calculate(\"grammar.follow\");\n\n  for (i = 0; i < automaton.length; i++) {\n\n    state = automaton[i];\n    actions = {};\n\n    for (s in state.transitions) {\n      actions[s] = { shift: state.transitions[s] };\n    }\n\n    for (j = 0; j < state.items.length; j++) {\n\n      item = state.items[j];\n\n      if (item.production === -1) {\n\n        if (item.index === 1) {\n          addReduceAction(actions, END, item.production);\n        }\n\n      } else {\n\n        if (item.index == grammar.productions[item.production].length - 1) {\n\n          for (s of follow.get(grammar.productions[item.production][0])) {\n            addReduceAction(actions, s, item.production);\n          }\n\n        }\n\n      }\n\n    }\n\n    table.push(actions);\n\n  }\n\n  return table;\n\n}\n","var END = require(\"../../../../symbols\").END;\n\nmodule.exports = {\n\n  initial: function() {\n\n    return [ { production: -1, index: 0, lookahead: END } ];\n\n  },\n\n  closure: function(grammar, kernel) {\n\n    var i, j, l;\n    var item, remaining, symbol, lookaheads;\n    var start = grammar.calculate(\"grammar.start\");\n\n    // Which items were added in a given iteration?\n\n    var added;\n\n    // Which productions/lookaheads have we already used for the closure?\n\n    var used = {};\n\n    for (i = 0; i < grammar.productions.length; i++) {\n      used[i] = {};\n    }\n\n    // Copy the kernel as the initial list of items\n\n    var result = [];\n\n    for (i = 0; i < kernel.length; i++) {\n      result.push({ production: kernel[i].production, index: kernel[i].index, lookahead: kernel[i].lookahead });\n    }\n\n    // While we cannot add more items...\n\n    do {\n\n      added = [];\n\n      // For each item we have...\n\n      for (i = 0; i < result.length; i++) {\n\n        item = result[i];\n\n        // Find the nonterminal symbol...\n\n        // Find the stuff \"after the dot\" (taking into account the augmented grammar)\n\n        if (item.production === -1) {\n          remaining = [start].slice(item.index);\n        } else {\n          remaining = grammar.productions[item.production].slice(item.index + 1);\n        }\n\n        // Go to next item if this one is completed\n\n        if (remaining.length == 0) {\n          continue;\n        }\n\n        // the nonterminal symbol is the first thing after the dot\n\n        symbol = remaining[0];\n\n        // lookaheads\n        // first(gamma a) where the item is [A -> alpha . B gamma, a]\n\n        lookaheads = grammar.getFirst(remaining.slice(1).concat(item.lookahead));\n\n        // Add items for matching productions/lookaheads (which are not already\n        // used for the closure)\n\n        for (j = 0; j < grammar.productions.length; j++) {\n\n          if (grammar.productions[j][0] == symbol) {\n\n            // Add an item for every lookahead...\n\n            for (l of lookaheads) {\n\n              if (!used[j][l]) {\n                added.push({ production: j, index: 0, lookahead: l });\n                used[j][l] = true;\n              }\n\n            }\n\n          }\n\n        }\n\n      }\n\n      for (i = 0; i < added.length; i++) {\n        result.push(added[i]);\n      }\n\n    } while (added.length > 0);\n\n    return result;\n\n  },\n\n  // this is basically identical to the LR0 version...\n  // could have a \"copy\" function for items?\n\n  transitions: function(grammar, closure) {\n\n    var result = {};\n    var i;\n    var item, symbol;\n    var start = grammar.calculate(\"grammar.start\");\n\n    // For each item...\n\n    for (i = 0; i < closure.length; i++) {\n\n      item = closure[i];\n\n      // Calculate the leaving symbol by looking in the grammar's productions,\n      // handling the augmented grammar production as above.\n\n      if (item.production === -1) {\n        symbol = [start][item.index];\n      } else {\n        symbol = grammar.productions[item.production][item.index + 1];\n      }\n\n      // If there is a leaving symbol, add the next item.\n\n      if (typeof symbol != \"undefined\") {\n\n        if (!result[symbol]) {\n          result[symbol] = [];\n        }\n\n        // copy it!\n\n        result[symbol].push({ production: item.production, index: item.index + 1, lookahead: item.lookahead });\n\n      }\n\n    }\n\n    return result;\n\n  },\n\n  same: function(a, b) {\n\n    var i, j;\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n\n      for (j = 0; j < b.length; j++) {\n\n        if (a[i].production === b[j].production && a[i].index === b[j].index && a[i].lookahead === b[j].lookahead) {\n          break;\n        }\n\n      }\n\n      if (j === b.length) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n}\n","var automaton = require(\"./helpers\").automaton;\nvar lr1 = require(\"./build/lr1\");\n\nmodule.exports = function(grammar) {\n\n  return automaton(grammar, lr1);\n\n}\n","var classifyLR1 = require(\"./helpers\").classifyLR1;\n\nmodule.exports = function(grammar) {\n\n  return classifyLR1(grammar.calculate(\"parsing.lr.lr1_table\"));\n\n}\n","var END = require(\"../../../symbols\").END;\nvar addReduceAction = require(\"./helpers\").addReduceAction;\n\nmodule.exports = function(grammar) {\n\n  var i, j, s;\n  var state, actions, item;\n  var table = [];\n  var automaton = grammar.calculate(\"parsing.lr.lr1_automaton\");\n\n  for (i = 0; i < automaton.length; i++) {\n\n    state = automaton[i];\n    actions = {};\n\n    for (s in state.transitions) {\n      actions[s] = { shift: state.transitions[s] };\n    }\n\n    for (j = 0; j < state.items.length; j++) {\n\n      item = state.items[j];\n\n      if (item.production === -1) {\n\n        if (item.index === 1) {\n          addReduceAction(actions, END, item.production);\n        }\n\n      } else {\n\n        if (item.index == grammar.productions[item.production].length - 1) {\n          addReduceAction(actions, item.lookahead, item.production);\n        }\n\n      }\n\n    }\n\n    table.push(actions);\n\n  }\n\n  return table;\n\n}\n","var classifyLR1 = require(\"./helpers\").classifyLR1;\n\nmodule.exports = function(grammar) {\n\n  return classifyLR1(grammar.calculate(\"parsing.lr.lalr1_table\"));\n\n}\n","var collapseLookaheads = require(\"./helpers\").collapseLookaheads;\nvar lr0 = require(\"./build/lr0\");\nvar mergeItems = require(\"./helpers\").mergeItems;\n\nmodule.exports = function(grammar) {\n\n  var i, j;\n\n  // Get the LR1 automaton.\n\n  var automaton = grammar.calculate(\"parsing.lr.lr1_automaton\");\n\n  // Collapse lookaheads.\n\n  for (i = 0; i < automaton.length; i++) {\n\n    automaton[i].kernel = collapseLookaheads(automaton[i].kernel);\n    automaton[i].items = collapseLookaheads(automaton[i].items);\n\n  }\n\n  // Find states to merge.\n  //\n  // Produce a list like this:\n  //\n  //   merge = [[0], [1, 2], [3, 5], [4]]\n  //\n  // where merge[i] is a list of indices in the dfa that can be merged.\n  //\n  // states can be merged if they have the same items, not considering lookaheads.\n\n  var used = [];\n  var merge = [];\n\n  for (i = 0; i < automaton.length; i++) {\n\n    // If this state has been used already for merging, skip it.\n\n    if (used[i]) {\n      continue;\n    }\n\n    // Otherwise, find the states (including the current state) which can be merged with it.\n\n    var m = [];\n\n    for (j = 0; j < automaton.length; j++) {\n\n      if (!used[j] && lr0.same(automaton[i].kernel, automaton[j].kernel)) {\n\n        m.push(j);\n        used[j] = true;\n\n      }\n\n    }\n\n    merge.push(m);\n\n  }\n\n  // for fixing transitions. looks like:\n  //\n  //   transition = [0, 1, 1, 3, 4, 3]\n  //\n  // where transition[i] is the new index for the original state i.\n\n  var transition = [];\n\n  for (i = 0; i < merge.length; i++) {\n    for (j = 0; j < merge[i].length; j++) {\n\n      transition[merge[i][j]] = i;\n\n    }\n  }\n\n  // Produce new states\n\n  var states = [];\n\n  for (i = 0; i < merge.length; i++) {\n\n    var state = { kernel: [], items: [], transitions: {} };\n\n    // Merge items\n\n    for (j = 0; j < merge[i].length; j++) {\n\n      state.kernel = mergeItems(automaton[merge[i][j]].kernel, state.kernel);\n      state.items = mergeItems(automaton[merge[i][j]].items, state.items);\n\n    }\n\n    // Add transitions (just use the first merge index)\n\n    var original = automaton[merge[i][0]].transitions;\n    var s;\n\n    for (s in original) {\n      state.transitions[s] = transition[original[s]];\n    }\n\n    // Add the new state\n\n    states.push(state);\n\n  }\n\n  return states;\n\n}\n","var addReduceAction = require(\"./helpers\").addReduceAction;\nvar END = require(\"../../../symbols\").END;\n\nmodule.exports = function(grammar) {\n\n  var i, j, k, s;\n  var state, actions, item;\n  var table = [];\n  var automaton = grammar.calculate(\"parsing.lr.lalr1_automaton\");\n\n  for (i = 0; i < automaton.length; i++) {\n\n    state = automaton[i];\n    actions = {};\n\n    for (s in state.transitions) {\n      actions[s] = { shift: state.transitions[s] };\n    }\n\n    for (j = 0; j < state.items.length; j++) {\n\n      item = state.items[j];\n\n      if (item.production === -1) {\n\n        if (item.index === 1) {\n          addReduceAction(actions, END, item.production);\n        }\n\n      } else {\n\n        if (item.index == grammar.productions[item.production].length - 1) {\n\n          for (k = 0; k < item.lookaheads.length; k++) {\n            addReduceAction(actions, item.lookaheads[k], item.production);\n          }\n\n        }\n\n      }\n\n    }\n\n    table.push(actions);\n\n  }\n\n  return table;\n\n}\n","function expand(grammar, production, symbol) {\n\n  var i;\n\n  var changes = [];\n\n  // Remove the existing production\n\n  changes.push({ operation: \"delete\", index: production });\n\n  // Add new productions\n\n  var offset = 0;\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    if (grammar.productions[i][0] === grammar.productions[production][symbol]) {\n\n      var p = grammar.productions[production].slice();\n      var b = grammar.productions[i].slice(1);\n      Array.prototype.splice.apply(p, [symbol, 1].concat(b));\n\n      changes.push({ production: p, operation: \"insert\", index: production + offset });\n      offset++;\n\n    }\n\n  }\n\n  return changes;\n\n}\n\nmodule.exports = function(grammar) {\n\n  var i, j;\n\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var result = [];\n\n  // Are there any nonterminals we can expand?\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    for (j = 1; j < grammar.productions[i].length; j++) {\n\n      if (nonterminals.has(grammar.productions[i][j])) {\n\n        result.push({\n          name: \"expand\",\n          production: i,\n          symbol: j,\n          changes: expand(grammar, i, j)\n        });\n\n      }\n\n    }\n  }\n\n  return result;\n\n}\n","function removeImmediateLeftRecursion(grammar, base, recursive) {\n\n  var i, j;\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var production;\n\n  // Find a new symbol for the right recursive production by adding primes\n  // to the existing symbol.\n\n  var symbol = grammar.productions[recursive[0]][0];\n\n  do {\n    symbol += \"'\";\n  } while (nonterminals.has(symbol));\n\n  // Copy productions to changes, marking those we're removing.\n\n  var changes = [];\n  var first;\n  var offset = 0;\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    if (base.indexOf(i) !== -1 || recursive.indexOf(i) !== -1) {\n\n      changes.push({ index: i + offset, operation: \"delete\" });\n      offset--;\n\n      if (typeof first === \"undefined\") {\n        first = i;\n      }\n    }\n\n  }\n\n  // Create the new productions...\n\n  offset = 0;\n\n  // Base rules\n\n  for (i = 0; i < base.length; i++) {\n\n    production = [];\n\n    for (j = 0; j < grammar.productions[base[i]].length; j++) {\n      production.push(grammar.productions[base[i]][j]);\n    }\n\n    production.push(symbol);\n\n    changes.push({ production: production, operation: \"insert\", index: first + offset });\n    offset++;\n\n  }\n\n  // Recursive rules\n\n  for (i = 0; i < recursive.length; i++) {\n\n    production = [];\n\n    production.push(symbol);\n\n    for (j = 2; j < grammar.productions[recursive[i]].length; j++) {\n      production.push(grammar.productions[recursive[i]][j]);\n    }\n\n    production.push(symbol);\n\n    changes.push({ production: production, operation: \"insert\", index: first + offset });\n    offset++;\n\n  }\n\n  // Epsilon\n\n  changes.push({ production: [symbol], operation: \"insert\", index: first + offset });\n\n  return changes;\n\n}\n\nmodule.exports = function(grammar) {\n\n  var i;\n\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var result = [];\n\n  var candidates = {};\n  var nt;\n\n  // Are there any rules of this form...\n  //\n  //   A -> A a_1 | A a_2 | ... | A a_m | b_1 | ... | b_n\n  //\n  // where m, n > 0?\n\n  for (nt of nonterminals) {\n    candidates[nt] = { recursive: [], base: [] };\n  }\n\n  for (i = 0; i < grammar.productions.length; i++) {\n    nt = grammar.productions[i][0];\n\n    if (nt == grammar.productions[i][1]) {\n      candidates[nt].recursive.push(i);\n    } else {\n      candidates[nt].base.push(i);\n    }\n  }\n\n  for (nt in candidates) {\n\n    if (candidates[nt].recursive.length > 0 && candidates[nt].base.length > 0) {\n\n      result.push({\n        name: \"removeImmediateLeftRecursion\",\n        production: candidates[nt].recursive[0],\n        symbol: 0,\n        changes: removeImmediateLeftRecursion(grammar, candidates[nt].base, candidates[nt].recursive)\n      });\n\n    }\n\n  }\n\n  return result;\n\n}\n","// Perform the left-factoring transformation. Group is an array of production\n// indices, and prefix is the number of symbols (not counting the head of\n// the production) to factor.\n\nfunction leftFactor(grammar, group, prefix) {\n\n  var i;\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n\n  // Find a new symbol...\n\n  var symbol = grammar.productions[group[0]][0];\n\n  do {\n    symbol += \"'\";\n  } while (nonterminals.has(symbol));\n\n  // Copy productions to changes, marking those we're removing.\n\n  var changes = [];\n  var offset = 0;\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    if (group.indexOf(i) !== -1) {\n      changes.push({ index: i + offset, operation: \"delete\" });\n      offset--;\n    }\n\n  }\n\n  // Add the reference to the new symbol with the factored prefix\n\n  changes.push({\n    production: grammar.productions[group[0]].slice(0, prefix + 1).concat(symbol),\n    operation: \"insert\",\n    index: group[0]\n  });\n\n  // Add the productions in the group\n\n  for (i = 0; i < group.length; i++) {\n    changes.push({\n      production: [symbol].concat(grammar.productions[group[i]].slice(prefix + 1)),\n      operation: \"insert\",\n      index: group[0] + i + 1\n    });\n  }\n\n  return changes;\n\n}\n\n// Mini trie implementation for finding factorable prefixes.\n\nfunction Trie() {\n\n  this.root = {\n    children: {},\n    values: []\n  };\n\n}\n\nTrie.prototype.insert = function(production, value) {\n\n  var node = this.root;\n  var i, s;\n\n  for (i = 0; i < production.length; i++) {\n    s = production[i];\n    if (typeof node.children[s] === \"undefined\") {\n      node.children[s] = { children: {}, values: [] };\n    }\n    node = node.children[s];\n  }\n\n  node.values.push(value);\n\n}\n\nTrie.prototype.getFactorablePrefixes = function() {\n\n  var groups = [];\n\n  function _values(length, node) {\n\n    var symbol;\n    var values = [];\n\n    values = values.concat(node.values);\n\n    for (symbol in node.children) {\n      values = values.concat(_values(length + 1, node.children[symbol]));\n    }\n\n    if (length > 0 && values.length >= 2) {\n      groups.push({ length: length, group: values });\n    }\n\n    return values;\n\n  }\n\n  _values(0, this.root);\n\n  return groups;\n\n}\n\nmodule.exports = function(grammar) {\n\n  var i;\n  var result = [];\n  var nt;\n\n  // Build tries for each nonterminal's productions\n\n  var productions = {};\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    nt = grammar.productions[i][0];\n\n    if (typeof productions[nt] === \"undefined\") {\n      productions[nt] = new Trie();\n    }\n\n    productions[nt].insert(grammar.productions[i].slice(1), i);\n\n  }\n\n  // Get factorable prefixes and their corresponding productions\n\n  var factorable;\n\n  for (nt in productions) {\n\n    factorable = productions[nt].getFactorablePrefixes();\n\n    for (i = 0; i < factorable.length; i++) {\n\n      var length = factorable[i].length;\n      var group = factorable[i].group;\n      group.sort();\n\n      result.push({\n        name: \"leftFactor\",\n        production: group[0],\n        symbol: 0,\n        length: length,\n        changes: leftFactor(grammar, group, length)\n      });\n\n    }\n\n  }\n\n  return result;\n\n}\n","function epsilonSeparate(grammar, group, epsilon) {\n\n  var i;\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n\n  // Find a new symbol...\n\n  var symbol = grammar.productions[group[0]][0];\n\n  do {\n    symbol += \"*\";\n  } while (nonterminals.has(symbol));\n\n  // Copy productions to changes, marking those we're removing.\n\n  var changes = [];\n  var offset = 0;\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    if (group.indexOf(i) !== -1 || i === epsilon) {\n      changes.push({ index: i + offset, operation: \"delete\" });\n      offset--;\n    }\n\n  }\n\n  // Add the separated version of the original rule\n\n  changes.push({\n    production: [grammar.productions[group[0]][0], symbol],\n    operation: \"insert\",\n    index: group[0]\n  });\n\n  changes.push({\n    production: [grammar.productions[group[0]][0]],\n    operation: \"insert\",\n    index: group[0] + 1\n  });\n\n  // Add the non-epsilon production bodies with the new head\n\n  for (i = 0; i < group.length; i++) {\n    changes.push({\n      production: [symbol].concat(grammar.productions[group[i]].slice(1)),\n      operation: \"insert\",\n      index: group[0] + i + 2\n    });\n  }\n\n  return changes;\n\n}\n\nmodule.exports = function(grammar) {\n\n  var nt, i;\n  var nonterminals = grammar.calculate(\"grammar.nonterminals\");\n  var result = [];\n  var group;\n  var epsilon;\n\n  // For each nonterminal, determine if it is unambiguously nullable,\n  // while collecting its non-null productions and its null (epsilon)\n  // production. If it is unambiguously nullable, add it to the result.\n\n  for (nt of nonterminals) {\n\n    group = [];\n    epsilon = -1;\n\n    for (i = 0; i < grammar.productions.length; i++) {\n\n      if (grammar.productions[i][0] === nt) {\n\n        if (grammar.productions[i].length === 1) {\n          if (epsilon !== -1) {\n            break;\n          }\n          epsilon = i;\n        } else {\n          group.push(i);\n        }\n\n      }\n\n    }\n\n    if (i === grammar.productions.length && group.length > 0 && epsilon !== -1) {\n\n      result.push({\n        name: \"epsilonSeparate\",\n        production: group[0],\n        symbol: 0,\n        changes: epsilonSeparate(grammar, group, epsilon)\n      });\n\n    }\n\n  }\n\n  return result;\n\n}\n","function removeUnreachable(grammar, group) {\n\n  var i;\n\n  var changes = [];\n  var offset = 0;\n\n  // Remove all productions in the group.\n\n  for (i = 0; i < grammar.productions.length; i++) {\n\n    if (group.indexOf(i) !== -1) {\n      changes.push({ index: i + offset, operation: \"delete\" });\n      offset--;\n    }\n\n  }\n\n  return changes;\n\n}\n\nmodule.exports = function(grammar) {\n\n  var unreachable = grammar.calculate(\"grammar.unreachable\");\n  var nt;\n  var i;\n  var result = [];\n  var group;\n\n  for (nt of unreachable) {\n\n    group = [];\n\n    for (i = 0; i < grammar.productions.length; i++) {\n\n      if (grammar.productions[i][0] === nt) {\n        group.push(i);\n      }\n\n    }\n\n    if (group.length > 0) {\n\n      result.push({\n        name: \"removeUnreachable\",\n        production: group[0],\n        symbol: 0,\n        changes: removeUnreachable(grammar, group)\n      });\n\n    }\n\n  }\n\n  return result;\n\n}\n","module.exports = function(grammar) {\n  return [].concat(grammar.calculate(\"transformations.expand\"))\n           .concat(grammar.calculate(\"transformations.removeImmediateLeftRecursion\"))\n           .concat(grammar.calculate(\"transformations.leftFactor\"))\n           .concat(grammar.calculate(\"transformations.epsilonSeparate\"))\n           .concat(grammar.calculate(\"transformations.removeUnreachable\"));\n}\n","module.exports[\"grammar.classification\"] = require(\"./grammar/classification\");\nmodule.exports[\"grammar.nonterminals\"] = require(\"./grammar/nonterminals\");\nmodule.exports[\"grammar.terminals\"] = require(\"./grammar/terminals\");\nmodule.exports[\"grammar.symbolInfo\"] = require(\"./grammar/symbolInfo\");\nmodule.exports[\"grammar.start\"] = require(\"./grammar/start\");\nmodule.exports[\"grammar.productions\"] = require(\"./grammar/productions\");\nmodule.exports[\"grammar.unreachable\"] = require(\"./grammar/unreachable\");\nmodule.exports[\"grammar.unrealizable\"] = require(\"./grammar/unrealizable\");\nmodule.exports[\"grammar.cycle\"] = require(\"./grammar/cycle\");\nmodule.exports[\"grammar.nullAmbiguity\"] = require(\"./grammar/nullAmbiguity\");\nmodule.exports[\"grammar.nullable\"] = require(\"./grammar/nullable\");\nmodule.exports[\"grammar.first\"] = require(\"./grammar/first\");\nmodule.exports[\"grammar.follow\"] = require(\"./grammar/follow\");\nmodule.exports[\"grammar.endable\"] = require(\"./grammar/endable\");\nmodule.exports[\"grammar.sentences\"] = require(\"./grammar/sentences\");\nmodule.exports[\"grammar.ambiguous\"] = require(\"./grammar/ambiguous\");\nmodule.exports[\"parsing.ll.ll1_classification\"] = require(\"./parsing/ll/ll1_classification\");\nmodule.exports[\"parsing.ll.ll1_table\"] = require(\"./parsing/ll/ll1_table\");\nmodule.exports[\"parsing.lr.lr0_classification\"] = require(\"./parsing/lr/lr0_classification\");\nmodule.exports[\"parsing.lr.lr0_automaton\"] = require(\"./parsing/lr/lr0_automaton\");\nmodule.exports[\"parsing.lr.lr0_table\"] = require(\"./parsing/lr/lr0_table\");\nmodule.exports[\"parsing.lr.slr1_classification\"] = require(\"./parsing/lr/slr1_classification\");\nmodule.exports[\"parsing.lr.slr1_table\"] = require(\"./parsing/lr/slr1_table\");\nmodule.exports[\"parsing.lr.lr1_automaton\"] = require(\"./parsing/lr/lr1_automaton\");\nmodule.exports[\"parsing.lr.lr1_classification\"] = require(\"./parsing/lr/lr1_classification\");\nmodule.exports[\"parsing.lr.lr1_table\"] = require(\"./parsing/lr/lr1_table\");\nmodule.exports[\"parsing.lr.lalr1_classification\"] = require(\"./parsing/lr/lalr1_classification\");\nmodule.exports[\"parsing.lr.lalr1_automaton\"] = require(\"./parsing/lr/lalr1_automaton\");\nmodule.exports[\"parsing.lr.lalr1_table\"] = require(\"./parsing/lr/lalr1_table\");\nmodule.exports[\"transformations.expand\"] = require(\"./transformations/expand\");\nmodule.exports[\"transformations.removeImmediateLeftRecursion\"] = require(\"./transformations/removeImmediateLeftRecursion\");\nmodule.exports[\"transformations.leftFactor\"] = require(\"./transformations/leftFactor\");\nmodule.exports[\"transformations.epsilonSeparate\"] = require(\"./transformations/epsilonSeparate\");\nmodule.exports[\"transformations.removeUnreachable\"] = require(\"./transformations/removeUnreachable\");\nmodule.exports[\"transformations.all\"] = require(\"./transformations/all\");\n","const Calculations = require(\"./calculations\");\nconst END = require(\"./symbols\").END;\n\nmodule.exports = class Grammar {\n  constructor(productions) {\n    var i, j;\n\n    if (!(productions instanceof Array)) {\n      throw new Error(\"List of productions must be an array\");\n    }\n\n    if (productions.length < 1) {\n      throw new Error(\"A grammar must have at least one production\");\n    }\n\n    for (i = 0; i < productions.length; i++) {\n      if (!(productions[i] instanceof Array)) {\n        throw new Error(\"Productions must be arrays\");\n      }\n\n      if (productions[i].length < 1) {\n        throw new Error(\"Productions must have at least one symbol\");\n      }\n\n      for (j = 0; j < productions[i].length; j++) {\n        if (typeof productions[i][j] !== \"string\") {\n          throw new Error(\"Production symbols must be strings\");\n        }\n\n        if (productions[i][j].match(/^Grammar\\./)) {\n          throw new Error(\"Reserved symbol \" + productions[i][j] + \" may not be part of a production\");\n        }\n\n        if (productions[i][j] === \"\") {\n          throw new Error(\"An empty symbol may not be part of a production\");\n        }\n      }\n    }\n\n    this.productions = productions;\n    this.calculations = {};\n  }\n\n  calculate(name, params = {}) {\n\n    // if (typeof Calculations[name] === \"undefined\") {\n    //   throw new Error(\"Undefined grammar calculation \" + name);\n    // }\n    //\n    // if (typeof this.calculations[name] === \"undefined\") {\n    //   this.calculations[name] = Calculations[name](this, params);\n    // }\n\n    // TODO: temp fix, add smarter caching back\n    return Calculations[name](this, params);\n  }\n\n  transform(transformation) {\n\n    var productions = this.productions.slice();\n\n    transformation.changes.forEach(function(change) {\n\n      if (change.operation === \"delete\") {\n        productions.splice(change.index, 1);\n      } else if (change.operation === \"insert\") {\n        productions.splice(change.index, 0, change.production);\n      }\n\n    });\n\n    return new Grammar(productions);\n\n  }\n\n  getFirst(symbols) {\n\n    var i, k;\n    var s;\n    var result;\n\n    var first = this.calculate(\"grammar.first\");\n    var nullable = this.calculate(\"grammar.nullable\");\n    var terminals = this.calculate(\"grammar.terminals\");\n    var nonterminals = this.calculate(\"grammar.nonterminals\");\n\n    result = new Set();\n\n    for (i = 0; i < symbols.length; i++) {\n\n      s = symbols[i];\n\n      if (s === END) {\n\n        result.add(s);\n        break;\n\n      } else if (terminals.has(s)) {\n\n        result.add(s);\n        break;\n\n      } else if (nonterminals.has(s)) {\n\n        for (k of first.get(s)) {\n          result.add(k);\n        }\n\n        if (!nullable.has(s)) {\n          break;\n        }\n\n      } else {\n\n        throw new Error(\"Unexpected symbol \" + s);\n\n      }\n\n    }\n\n    return result;\n\n  }\n\n  isNullable(symbols) {\n\n    var i, s;\n\n    var nullable = this.calculate(\"grammar.nullable\");\n    var terminals = this.calculate(\"grammar.terminals\");\n    var nonterminals = this.calculate(\"grammar.nonterminals\");\n\n    for (i = 0; i < symbols.length; i++) {\n\n      s = symbols[i];\n\n      if (nonterminals.has(s)) {\n\n        if (!nullable.has(s)) {\n          return false;\n        }\n\n      } else if (terminals.has(s)) {\n\n        return false;\n\n      } else {\n\n        throw new Error(\"Unexpected symbol \" + s);\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  copyProductions() {\n\n    var i, j;\n    var result = [];\n\n    for (i = 0; i < this.productions.length; i++) {\n      result[i] = [];\n\n      for (j = 0; j < this.productions[i].length; j++) {\n        result[i][j] = this.productions[i][j];\n      }\n    }\n\n    return result;\n\n  }\n\n  toString() {\n\n    var i, j;\n    var result = \"\";\n\n    for (i = 0; i < this.productions.length; i++) {\n\n      result += this.productions[i][0];\n      result += \" ->\";\n\n      for (j = 1; j < this.productions[i].length; j++) {\n        result += \" \" + this.productions[i][j];\n      }\n\n      result += \" .\\n\";\n\n    }\n\n    return result;\n\n  }\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node (1024).\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap();\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n    /// to the given position and side.\n    cursor(pos, side = 0) {\n        let scope = (pos != null && CachedNode.get(this)) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        if (pos != null) {\n            cursor.moveTo(pos, side);\n            CachedNode.set(this, cursor._tree);\n        }\n        return cursor;\n    }\n    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip through\n    /// [anonymous](#common.NodeType.isAnonymous) nodes.\n    fullCursor() {\n        return new TreeCursor(this.topNode, 1 /* Full */);\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        return this.cursor(pos, side).node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let result = this.topNode;\n        for (;;) {\n            let inner = result.enter(pos, side);\n            if (!inner)\n                return result;\n            result = inner;\n        }\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor(), get = () => c.node;;) {\n            let mustLeave = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n                if (c.firstChild())\n                    continue;\n                if (!c.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(c.type, c.from, c.to, get);\n                mustLeave = c.type.isAnonymous;\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(this.type, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nclass TreeNode {\n    constructor(node, _from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this.node = node;\n        this._from = _from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this.node.type; }\n    get name() { return this.node.type.name; }\n    get from() { return this._from; }\n    get to() { return this._from + this.node.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent._from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & 2 /* NoEnterBuffer */)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent.node.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, overlays = true, buffers = true) {\n        let mounted;\n        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return this.node; }\n    toTree() { return this.node; }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this.node.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor, result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, overlays, buffers = true) {\n        if (!buffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        this.buffer = null;\n        this.stack = [];\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, overlays = true, buffers = true) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, overlays, buffers));\n        return buffers ? this.enterChild(1, pos, side) : false;\n    }\n    /// Move the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n                    let child = parent.node.children[i];\n                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree.node;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = node.children.reduce((s, ch) => s + nodeSize(balanceType, ch), 1);\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type to tag the resulting tree with. Will also be used for\n// internal nodes when it is an anonymous type\ntype, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(type, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(type, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(type, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom];\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(type, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\n///\n/// The nesting function is passed a cursor to provide context for a\n/// node, but _should not_ move that cursor, only inspect its\n/// properties and optionally access its\n/// [node object](#common.TreeCursor.node).\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n        }\n        if (this.innerDone == this.inner.length)\n            return this.baseTree;\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let next = this.inner[this.innerDone];\n        return next ? next.parse.parsedPos : this.input.length;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        scan: for (let cursor = this.baseTree.fullCursor(), nest, overlay = null;;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to)\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree));\n                    enter = false;\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target));\n                        overlay = overlay.prev;\n                    }\n                }\n            }\n        }\n    }\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let isTarget = b[i + 1] + off == node.from && b[i + 2] + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], b[i + 1]));\n        positions.push(b[i + 1] - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        let last = children.length - 1;\n        return new Tree(type, children, positions, positions[last] + children[last].length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.fullCursor();\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        this.fragments = fragments;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curFrag.to)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curFrag.to >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n        }\n    }\n    return result;\n}\n\nexports.DefaultBufferLength = DefaultBufferLength;\nexports.MountedTree = MountedTree;\nexports.NodeProp = NodeProp;\nexports.NodeSet = NodeSet;\nexports.NodeType = NodeType;\nexports.Parser = Parser;\nexports.Tree = Tree;\nexports.TreeBuffer = TreeBuffer;\nexports.TreeCursor = TreeCursor;\nexports.TreeFragment = TreeFragment;\nexports.parseMixed = parseMixed;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar common = require('@lezer/common');\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, pos, value stack pos (15 bits array index, 15 bits\n    /// buffer index) triplets for all but the top state\n    /// @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer. @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(s, this.pos);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        if (!this.p.parser.validAction(this.state, reduce)) {\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsing—when looking forward—or even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos > this.token.lookAhead)\n            this.token.lookAhead = pos;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos > this.token.lookAhead)\n            this.token.lookAhead = this.pos;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = token.lookAhead = pos;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        // Do a binary search on the state's edges\n        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.fullCursor();\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof common.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(common.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nconst dummyToken = new CachedToken;\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = dummyToken;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main) {\n            main = dummyToken;\n            main.start = stack.pos;\n            if (stack.pos == this.stream.end) {\n                main.value = stack.p.parser.eofTerm;\n                main.end = stack.pos;\n                actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n            }\n            else {\n                main.value = 0 /* Err */;\n                main.end = stack.pos + 1;\n            }\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        tokenizer.token(this.stream.reset(stack.pos, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = stack.pos + 1;\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 1), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    Rec[Rec[\"MinBufferLengthPrune\"] = 200] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654;\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.mainToken;\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(common.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof common.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof common.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return common.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass LRParser extends common.Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new common.NodeSet(nodeNames.map((name, i) => common.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.strict = false;\n        this.bufferLength = common.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\nexports.ContextTracker = ContextTracker;\nexports.ExternalTokenizer = ExternalTokenizer;\nexports.InputStream = InputStream;\nexports.LRParser = LRParser;\nexports.Stack = Stack;\n","const ExternalTokenizer = require(\"@lezer/lr\").ExternalTokenizer;\nconst symbolChars = require(\"./rules.terms\").symbolChars;\n\nconst space = [\n  9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196,\n  8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288\n];\nconst hyphen = 0x2D, gt = 0x3E, pipe = 0x7C, stop = 0x2E, hash = 0x23;\n\nmodule.exports.getSymbolChars = new ExternalTokenizer(function(input) {\n  for (let i = 0;; i++) {\n    if (\n      (input.next < 0) ||\n      (space.indexOf(input.next) > -1) ||\n      (input.next == hyphen && input.peek(1) == gt) ||\n      (input.next == pipe) ||\n      (input.next == stop) ||\n      (input.next == hash)\n    ) {\n      if (i > 0) {\n        input.acceptToken(symbolChars);\n      }\n      break;\n    } else {\n      input.advance();\n    }\n  }\n});\n","// This file was generated by lezer-generator. You probably shouldn't edit it.\nmodule.exports = {\n  symbolChars: 9,\n  rules: 1,\n  Rule: 2,\n  Head: 3,\n  Production: 4,\n  Symbol: 5\n}","// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst {LRParser} = require(\"@lezer/lr\")\nconst {getSymbolChars} = require(\"./tokens\")\nexports.parser = LRParser.deserialize({\n  version: 13,\n  states: \"#SQYQROOOOQO'#C_'#C_O_QQO'#C^OOQP'#Cb'#CbQYQROOOdQRO,58xOOQP-E6`-E6`OOQP'#Ca'#CaOOQP'#Cc'#CcOoQRO'#C`OOQO'#Cj'#CjOzQQO1G.dOOQP-E6a-E6aOdQRO,59UOOQP7+$O7+$OOOQO1G.p1G.p\",\n  stateData: \"!S~OZOS[OS~OXPO~O]TO~OXVO_SP`SP~OXVO_SX`SX~O_]O`^O~O\",\n  goto: \"!T_PP`dhnsyPPPPPP!QTROSTQOSQYTR_]VWTX]QSORUSSXT]R[XRZT\",\n  nodeNames: \"⚠ rules Rule Head Production Symbol\",\n  maxTerm: 16,\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"#d~R^X^}pq}st!r}!O!}!O!P#Y#p#q#_#y#z}$f$g}#BY#BZ}$IS$I_}$I|$JO}$JT$JU}$KV$KW}&FU&FV}~!SYZ~X^}pq}#y#z}$f$g}#BY#BZ}$IS$I_}$I|$JO}$JT$JU}$KV$KW}&FU&FV}~!wQ[~OY!rZ~!r~#QP!`!a#T~#YO]~~#_O`~~#dO_~\",\n  tokenizers: [getSymbolChars, 0],\n  topRules: {\"rules\":[0,1]},\n  tokenPrec: 0\n})\n","const parser = require(\"./rules\").parser;\n\nmodule.exports = function(src) {\n  let tree = parser.parse(src);\n  let cursor = tree.cursor();\n\n  let productions = [];\n  let head;\n  let production;\n\n  do {\n    if (cursor.type.isError) {\n      throw new Error(\"Parse error\");\n    }\n\n    if (cursor.name === \"Head\") {\n      head = src.slice(cursor.from, cursor.to);\n    } else if (cursor.name === \"Production\") {\n      production = [head];\n      productions.push(production);\n    } else if (cursor.name === \"Symbol\") {\n      production.push(src.slice(cursor.from, cursor.to));\n    }\n  } while (cursor.next());\n\n  return productions;\n}\n","var AnalysisController = require(\"./analysis_controller\");\nvar EditController = require(\"./edit_controller\");\nvar TransformController = require(\"./transform_controller\");\nvar ModeController = require(\"./mode_controller\");\nvar ErrorController = require(\"./error_controller\");\nvar Grammar = require(\"../grammar\");\nvar parser = require(\"../parser\");\n\nfunction parse(spec) {\n  if (spec.match(/^\\s*$/)) {\n    return { spec: spec };\n  }\n\n  try {\n    return { grammar: new Grammar(parser(spec)), spec: spec };\n  } catch (e) {\n    return { error: e, spec: spec };\n  }\n}\n\nmodule.exports = class ApplicationController {\n  constructor(element) {\n\n    this._element = element;\n\n    // master\n\n    this._masterElement = document.createElement(\"div\");\n    this._masterElement.id = \"master\";\n    this._element.appendChild(this._masterElement);\n\n    // edit\n\n    this._editElement = document.createElement(\"section\");\n    this._masterElement.appendChild(this._editElement);\n\n    this._editController = new EditController(this._editElement);\n    this._editController.setDelegate(this);\n\n    // mode\n\n    this._modeElement = document.createElement(\"section\");\n    this._masterElement.appendChild(this._modeElement);\n\n    this._modeController = new ModeController(this._modeElement);\n    this._modeController.setDelegate(this);\n\n    // error\n\n    this._errorElement = document.createElement(\"section\");\n    this._masterElement.appendChild(this._errorElement);\n\n    this._errorController = new ErrorController(this._errorElement);\n    this._errorController.setDelegate(this);\n\n    // transform\n\n    this._transformElement = document.createElement(\"section\");\n    this._masterElement.appendChild(this._transformElement);\n\n    this._transformController = new TransformController(this._transformElement);\n    this._transformController.setDelegate(this);\n\n    // analysis\n\n    this._analysisElement = document.createElement(\"section\");\n    this._element.appendChild(this._analysisElement);\n\n    this._analysisController = new AnalysisController(this._analysisElement);\n    this._analysisController.setDelegate(this);\n\n    // listen for hashchange events\n\n    window.location.hash = \"\";\n\n    window.addEventListener(\"hashchange\", function() {\n      this._hashChanged();\n    }.bind(this), false);\n\n    // set initial path and parse, and reload children\n\n    this._path = \"/\";\n    this._parse = { spec: \"# Type a grammar here:\\n\\n\" };\n    this._mode = \"edit\";\n\n    this._analysisController.reload();\n    this._editController.reload();\n    this._modeController.reload();\n\n    if (this._mode === \"edit\") {\n      this._errorController.reload();\n    } else {\n      this._transformController.reload();\n    }\n\n    this._layout();\n\n  }\n\n  _hashChanged() {\n\n    // get grammar and path\n\n    this._path = window.location.hash.slice(1);\n\n    if (this._path == \"\") {\n      this._path = \"/\";\n    }\n\n    // update controllers\n\n    this._analysisController.reload();\n\n  }\n\n  _layout() {\n\n    if (this._mode === \"edit\") {\n\n      this._editElement.style.display = '';\n      this._transformElement.style.display = 'none';\n\n      if (typeof this._parse.error === \"undefined\") {\n\n        this._errorElement.style.display = 'none';\n        this._editElement.style.top = this._modeElement.offsetHeight + \"px\";\n\n      } else {\n\n        this._errorElement.style.display = '';\n        this._errorElement.style.top = this._modeElement.offsetHeight + \"px\";\n        this._editElement.style.top = (this._modeElement.offsetHeight + this._errorElement.offsetHeight) + \"px\";\n\n      }\n\n    } else {\n\n      this._editElement.style.display = 'none';\n      this._errorElement.style.display = 'none';\n      this._transformElement.style.display = '';\n\n      this._transformElement.style.top = this._modeElement.offsetHeight + \"px\";\n\n    }\n\n  }\n\n  getPath() {\n\n    return this._path;\n\n  }\n\n  getGrammar() {\n\n    return this._parse.grammar;\n\n  }\n\n  getSpec() {\n\n    return this._parse.spec;\n\n  }\n\n  getError() {\n\n    return this._parse.error;\n\n  }\n\n  getMode() {\n\n    return this._mode;\n\n  }\n\n  grammarChanged(grammar) {\n\n    this._parse = { grammar: grammar, spec: grammar.toString() };\n\n    this._analysisController.reload();\n    this._layout();\n\n  }\n\n  analyze() {\n\n    this._parse = parse(this._editController.getSpec());\n\n    if (typeof this._parse.error === \"undefined\") {\n      this._analysisController.reload();\n    }\n\n    this._errorController.reload();\n    this._layout();\n\n  }\n\n  transform() {\n\n    this._parse = parse(this._editController.getSpec());\n\n    if (typeof this._parse.error === \"undefined\" && typeof this._parse.grammar !== \"undefined\") {\n      this._mode = \"transform\";\n      this._transformController.reload();\n    }\n\n    this._analysisController.reload();\n    this._errorController.reload();\n    this._modeController.reload();\n    this._layout();\n\n  }\n\n  edit() {\n\n    this._mode = \"edit\";\n\n    this._analysisController.reload();\n    this._editController.reload();\n    this._modeController.reload();\n    this._layout();\n\n  }\n}\n","var ApplicationController = require(\"./controllers/application_controller\");\n\nmodule.exports = ApplicationController;\n"],"names":["Vnode","tag","key","attrs","children","text","dom","domSize","undefined","state","events","instance","normalize","node","Array","isArray","normalizeChildren","String","input","length","isKeyed","i","TypeError","$window","currentRedraw","$doc","nameSpace","possibleParents","lisTemp","uppercaseRegex","vnode","require$$0","render","window","document","svg","math","caption","thead","tbody","tfoot","tr","th","td","colgroup","col","EventDict","prototype","Object","create","handleEvent","ev","result","handler","this","type","call","currentTarget","_","redraw","preventDefault","stopPropagation","vnodes","hooks","active","activeElement","namespace","namespaceURI","textContent","prevRedraw","updateNodes","focus","getNameSpace","xmlns","checkState","original","Error","callHook","apply","arguments","e","createNodes","parent","start","end","nextSibling","ns","createNode","initLifecycle","createTextNode","insertNode","createHTML","fragment","createDocumentFragment","firstChild","childNodes","createFragment","is","element","createElementNS","createElement","setAttr","setAttrs","maybeSetContentEditable","normalized","value","selectedIndex","setLateSelectAttrs","sentinel","view","$$reentrantLock$$","initComponent","match","temp","innerHTML","child","push","appendChild","old","removeNodes","isOldKeyed","oldStart","o","v","oe","topSibling","oldEnd","ve","updateNode","getNextSibling","moveNodes","map","lisIndices","originalNextSibling","vnodesLength","oldIndices","li","pos","matched","oldIndex","getKeyMap","a","u","il","j","c","makeLisIndices","commonLength","removeNode","oldTag","force","onbeforeupdate","shouldNotUpdate","updateLifecycle","toString","nodeValue","updateText","removeHTML","updateFragment","val","isLifecycleMethod","updateStyle","hasPropertyKey","nsLastIndex","indexOf","slice","removeAttribute","updateEvent","removeAttr","updateAttrs","updateElement","updateComponent","frag","moveChildToFrag","parentNode","insertBefore","contenteditable","contentEditable","content","stateResult","attrsResult","next","mask","reallyRemove","onremove","removeChild","onbeforeremove","then","attr","setAttributeNS","setAttribute","toLowerCase","capital","normalizeKey","replace","style","cssText","setProperty","removeProperty","removeEventListener","addEventListener","source","oninit","oncreate","bind","onupdate","hyperscriptVnode","require$$1","selectorParser","selectorCache","hasOwn","hasOwnProperty","isEmpty","object","trust","html","hyperscript","selector","hasClass","className","class","newAttrs","execSelector","classes","exec","id","attrValue","join","compileSelector","hyperscript_1","m","template","path","segments","forEach","segment","href","title","header_view","constructor","_element","setDelegate","delegate","_delegate","reload","getPathComponents","blank_slate_view","symbols","END","PRIME","prettifySymbol","symbol","formatSymbol","info","nonterminals","has","terminals","ESCAPE","&","<",">","\"","escapeChar","char","escapeString","string","bareFormatSymbol","bareFormatSymbols","TRANSFORMATION_FORMATTERS","expand","transformation","productions","removeImmediateLeftRecursion","leftFactor","production","epsilonSeparate","removeUnreachable","count","array","set","order","separator","index","sentence","item","splice","lookaheads","lookahead","name","size","b","Set","k","values","add","Helpers","SetOperations","require$$2","unreachable","unrealizable","cycle","nullAmbiguity","ambiguous","any","formatSymbolList","listSymbols","productionOrder","formatProduction","formatSentence","formatAmbiguous","maxSentences","maxDepth","sentences","limit","labelStyle","marginRight","labelTextStyle","placeholder","onchange","target","valueAsNumber","onclick","onCalculate","whiteSpace","nullable","endable","first","follow","firstSymbols","get","followSymbols","terminalOrder","MDASH","formatClassification","cs","n","member","reason","classification","scope","table","fillArray","nt","concat","t","p","lr_automaton_graph","automaton","items","bareFormatItem","s","transitions","nonterminalOrder","actions","shift","reduce","isConflict","lr1_table","HeaderView","BlankSlateView","SanityView","getCalculation","SentencesView","params","console","log","ShortSentencesView","NonterminalsView","ParsingView","LL1TableView","LR0AutomatonView","dot","Viz","LR0TableView","SLR1TableView","LR1AutomatonView","LR1TableView","LALR1AutomatonView","LALR1TableView","analysis_controller","_blankSlateElement","_blankSlateView","_headerElement","_headerView","_routes","/","views","/ll1-table","/lr0-automaton","/lr0-table","/slr1-table","/lr1-automaton","/lr1-table","/lalr1-automaton","/lalr1-table","/sentences","_views","pathChanged","_grammar","getGrammar","getPath","_path","teardown","route","setup","display","scrollLeft","scrollTop","calculate","spec","edit_controller","getSpec","querySelector","formatTransformation","undoTransformation","redoTransformation","transformations","buttons","data-action","productionTransformations","disabled","selected","TransformView","dataset","action","undo","redo","parseInt","transform","_transformations","getTransformations","getProductions","getSymbolInfo","getUndoTransformation","getRedoTransformation","transform_controller","_transformElement","_transformView","_index","_stack","grammar","getPreviousSymbolInfo","productionIndex","symbolIndex","grammarChanged","mode","checked","for","ll1","lr0","slr1","lr1","lalr1","symbolInfo","mode_controller","edit","analyze","getMode","error_controller","error","getError","Relation","iterable","_map","Map","keys","Symbol","iterator","l","entries","propagate","propagation","closed","closure","dfs","w","relation","added","marked","found","head","immediate","expanded","queue","steps","replacement","nonterminalCount","expandSentenceNode","sort","ll1_classification","body","getFirst","intersection","ll1_table","isNullable","lr0_classification","build","kernel","states","initial","same","x","lr0_automaton","used","lr0_table","classifyLR1","slr1_classification","addReduceAction","slr1_table","remaining","lr1_automaton","lr1_classification","lalr1_classification","collapseLookaheads","mergeItems","lalr1_automaton","merge","transition","lalr1_table","expand_1","changes","operation","offset","removeImmediateLeftRecursion_1","candidates","recursive","base","Trie","root","insert","getFactorablePrefixes","groups","_values","group","leftFactor_1","factorable","prefix","epsilonSeparate_1","epsilon","removeUnreachable_1","all","exports","module","require$$3","require$$4","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","require$$21","require$$22","require$$23","require$$24","require$$25","require$$26","require$$27","require$$28","require$$29","require$$30","require$$31","require$$32","require$$33","require$$34","Calculations","Grammar","calculations","change","copyProductions","defineProperty","dist","nextPropID","Range","from","to","NodeProp","config","perNode","deserialize","RangeError","NodeType","closedBy","str","split","openedBy","contextHash","lookAhead","mounted","MountedTree","tree","overlay","parser","noProps","props","flags","define","top","skipped","src","prop","isTop","isSkipped","isError","isAnonymous","direct","none","CachedNode","WeakMap","Tree","positions","ch","test","JSON","stringify","cursor","side","topNode","TreeCursor","moveTo","_tree","fullCursor","TreeNode","resolve","resolveInner","inner","enter","iterate","leave","mustLeave","propValues","balance","balanceRange","makeTree","data","buffer","nodeSet","maxBufferLength","reused","minRepeatType","types","FlatBufferCursor","takeNode","parentStart","minPos","inRepeat","lookAheadAtStart","startPos","maxSize","fork","skip","minStart","scan","nodeSize","localSkipped","nodeStart","findBufferSize","Uint16Array","endPos","copyToBuffer","bufferStart","startIndex","TreeBuffer","localChildren","localPositions","localInRepeat","lastGroup","lastEnd","makeRepeatLeaf","reverse","make","lastI","last","lookAheadProp","pop","pair","_a","topID","empty","childString","endIndex","findChild","dir","pick","checkSide","startI","endI","copy","_from","_parent","nextChild","BufferNode","BufferContext","hasChild","lastChild","childAfter","childBefore","overlays","buffers","rPos","nextSignificantParent","prevSibling","toTree","getChild","before","after","r","getChildren","cur","context","externalSibling","stack","bufferNode","yieldNode","unshift","yieldBuf","yield","enterChild","sibling","d","atLastNode","move","prev","cache","depth","some","nodeSizeCache","balanceType","mkTop","mkTree","total","maxChild","Math","ceil","divide","groupFrom","groupStart","groupSize","nextSize","only","TreeFragment","openStart","openEnd","open","addTree","fragments","partial","f","applyChanges","minGap","fI","nextF","cI","off","fFrom","fTo","nextC","nextPos","fromA","cut","max","min","toA","toB","StringInput","chunk","lineChunks","read","InnerParse","parse","ActiveOverlay","predicate","mounts","ranges","MixedParse","nest","innerDone","baseTree","stoppedAt","baseParse","advance","done","startInner","assign","parsedPos","stopAt","fragmentCursor","FragmentCursor","range","hasNode","find","mount","oldMounts","buf","innerOffset","sliceBuf","isTarget","materialize","findMounts","punchRanges","startParse","enterFragments","nodes","StructureCursor","fragI","curFrag","nextFrag","outer","current","gapFrom","gapTo","iA","iB","inA","inB","nextA","nextB","findCoverChanges","NodeSet","extend","newTypes","newProps","createParse","Recover","Safety","common","Stack","reducePos","score","bufferBase","curContext","filter","cx","StackContext","pushState","dPrec","dynamicPrecedence","minRepeatTerm","storeNode","getGoto","reduceContext","stateFlag","baseStateID","term","isReduce","nextEnd","nextState","maxNode","shiftContext","useNode","updateContext","tracker","reuse","stream","reset","recoverByDelete","isNode","canShift","sim","SimulatedStack","stateSlot","hasAction","recoverByInsert","nextStates","best","forceReduce","validAction","forceAll","deadEnd","restart","sameState","other","dialectEnabled","dialectID","dialect","emitContext","hash","emitLookAhead","newCx","setLookAhead","close","strict","goto","StackBufferCursor","maybeNext","CachedToken","extended","nullToken","InputStream","chunkOff","chunk2","chunk2Pos","token","rangeIndex","chunkPos","readNext","resolveOffset","assoc","peek","idx","charCodeAt","resolved","acceptToken","endOffset","getChunk","nextChunk","setDone","TokenGroup","groupMask","accEnd","allows","overrides","low","high","mid","readToken","contextual","fallback","decodeArray","Type","out","stop","digit","verbose","process","env","LOG","stackIDs","cutAt","safeFrom","safeTo","trees","nextFragment","fr","nextStart","nodeAt","dummyToken","TokenCache","tokens","mainToken","tokenizers","getActions","actionIndex","main","tokenizer","updateCachedToken","addActions","eofTerm","specialized","specializers","putAction","Rec","Parse","recovering","nextStackID","minStackPos","topTerm","stacks","bufferLength","newStacks","stopped","stoppedTokens","advanceStack","tok","finished","findFinished","stackToTree","getName","SyntaxError","runRecovery","maxRemaining","stackID","strictCx","cxHash","cached","defaultReduce","localStack","advanceFully","pushStackDedup","restarted","tokenEnd","forceBase","fromCodePoint","Dialect","LRParser","Parser","super","wrappers","version","nodeNames","repeatNodeCount","topTerms","topRules","nodeProps","setProp","nodeID","propSpec","skippedNodes","DefaultBufferLength","tokenArray","tokenData","Uint32Array","stateData","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","parseDialect","loose","groupTag","terminal","slot","flag","iPrev","findOffset","configure","contextTracker","wrap","prec","part","Uint8Array","options","ExternalTokenizer","space","getSymbolChars","rules","AnalysisController","EditController","TransformController","ModeController","ErrorController","ApplicationController","_masterElement","_editElement","_editController","_modeElement","_modeController","_errorElement","_errorController","_transformController","_analysisElement","_analysisController","location","_hashChanged","_parse","_mode","_layout","offsetHeight"],"mappings":"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"}